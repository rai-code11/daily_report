## 取り組んだ課題一覧
- React/todoリストリファクタリング
- TypeScript/演習

## わかったこと
```js
const completeCount = todoList.filter((t) => t.checked).length;
```
処理の仕組み
1. filter で選別: todoList という配列を1つずつループし、各要素を一時的に t という変数（引数）に代入します。
2. 条件判定: t.checked が true のもの（チェックが入っているタスク）だけを抽出した新しい配列を作ります。
3. 最後にカウント: その「チェック済みだけが集まった新しい配列」に対して .length を使うことで、最終的な個数（数値）を取得しています。

```js
  const onChangeTodoText = (e) => setTodoText(e.target.value);
```
- (e) は 「入力欄で起きた『変化』という出来事（イベント）の情報」
処理の流れを分解
1. 現在: useState が持っている「今の配列」がある。
2. 関数内: [...todoList] で、その瞬間の「今の配列」の**コピー（分身）**を関数の中に作る。
3. 加工: その分身に対して splice などで変更を加える（この時点ではまだ画面は変わらない）。
4. 報告: setTodoList(分身) を実行。
5. 更新: Reactが「分身」を「新しい正解（最新のState）」として受理し、それをもとに次の処理や画面表示が行われる。


**「関数ごとに最新の状態をコピーして、それを加工してReactに報告する」**というサイクル
Reactにおいては**「イミュータビリティ（不変性）」**というルールがこの動きの決め手になっている。
- なぜ毎回「新しい配列」を作るのか？
- Reactは、todoList という配列の中身（要素）が書き換わっただけでは、「あ、中身が変わったな！画面を更新しなきゃ！」と気づいてくれない性質があるから
* ダメな例（直接変更）: todoList.splice(index, 1)
    * これは「同じ配列（メモリ上の住所が同じ）」の中身をいじっているだけなので、Reactは「住所が変わってないから、中身も同じでしょ？」と判断し、画面が再描画されない
* 正解（新しい配列の作成）: const newTodos = [...todoList]
    * これで「新しい配列（新しいメモリ上の住所）」が生まれます。setTodoList(newTodos) を呼ぶことで、Reactは「お、住所が変わった！新しいデータだね、画面を書き換えよう！」と認識する

- 以下のようなリレー形式でデータが更新されていく
1. 現在: useState が持っている「今の配列」がある。
2. 関数内: [...todoList] で、その瞬間の「今の配列」の**コピー（分身）**を関数の中に作る。
3. 加工: その分身に対して splice などで変更を加える（この時点ではまだ画面は変わらない）。
4. 報告: setTodoList(分身) を実行。
5. 更新: Reactが「分身」を「新しい正解（最新のState）」として受理し、それをもとに次の処理や画面表示が行われる。

「もし editId と todo.id が一致していたら（編集モードなら）Aを、そうでなければBを表示する」という処理で、中身を詳しく書くと以下のようになる
基本的な書き方

```js

{editId === todo.id ? (
  // 真の場合：編集用の入力フォームなど
  <input type="text" value={todo.text} />
) : (
  // 偽の場合：通常のテキスト表示など
  <span>{todo.text}</span>
)}
```

- 構文のポイント
* ? の前: 条件式（true か false かを判定）
* ? と : の間: 条件が true の時に実行・表示される内容
* : の後ろ: 条件が false の時に実行・表示される内容



- スプレッド構文（...）は、配列にもオブジェクトにも両方使える
- これがJavaScript（特にReact）で混乱しやすい、かつ最強に便利なポイントです。それぞれ「何をバラバラに展開するのか」が違う

1. オブジェクトに使う場合（今回のケース）
**「プロパティ（キーと値）」**をバラバラにして、新しいオブジェクトにコピーします。

```js

const user = { name: "田中", age: 25 };

// コピーして一部書き換える
const updatedUser = { ...user, age: 26 };

console.log(updatedUser); 
// 結果: { name: "田中", age: 26 }
今回の { ...todo, checked: !todo.checked } はまさにこれですね。
2. 配列に使う場合
**「配列の中身（要素）」**をバラバラにして、新しい配列にコピー
```
```JavaScript

const fruits = ["apple", "banana"];

// コピーして新しい要素を追加する
const newFruits = [...fruits, "orange"];

console.log(newFruits);
// 結果: ["apple", "banana", "orange"]


const newTodos = todoList.filter((todo) => todo.id !== id);
```

todo.id !== id が true のものだけを残すという意味。


## 次やること
- 面談
- TypeScript:udemy


## 感じたこと
- エラーが出た際にコンソールに出して値を追ったら時間はかかったがReactの動きが理解できた。

## 学習時間
- 6.75h
