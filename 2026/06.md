## 取り組んだ課題一覧
- JavaScript Primer

## わかったこと

## オブジェクト

オブジェクトはプロパティの集合です。プロパティとは名前（キー）と値（バリュー）が対になったものです。

## オブジェクトを作成する

```javascript
// プロパティを持たない空のオブジェクトを作成
const obj = {};
```
```javascript
// プロパティを持つオブジェクトを定義する
const obj = {
    // キー: 値
    "key": "value"
};
```javascript
オブジェクトリテラルのプロパティ名（キー）はクォート（"や'）を省略できます。 そのため、次のように書いても同じです。
```

```javascript
// プロパティ名（キー）はクォートを省略することが可能
const obj = {
    // キー: 値
    key: "value"
};
```

数名として利用できないプロパティ名はクォート（"や'）で囲む必要があり
```javascript
const object = {
    // キー: 値
    my-prop: "value" // NG
};

```
my-propというプロパティ名を定義する場合は、クォート（"や'）で囲む必要があります。
```javascript
const obj = {
    // キー: 値
    "my-prop": "value" // OK
};
```

複数のプロパティを定義するには、それぞれのプロパティを,（カンマ）で区切ります。
```javascript
const color = {
    // それぞれのプロパティは`,`で区切る
    red: "red",
    green: "green",
    blue: "blue"
};
```
```javascript
const name = "名前";
// `name`というプロパティ名で`name`の変数を値に設定したオブジェクト
const obj = {
    name: name
};
console.log(obj); // => { name: "名前" }
```


プロパティ名と値に指定する変数名が同じ場合は{ name }のように省略して書けます。 次のコードは、プロパティ名nameに変数nameを値にしたプロパティを設定

```javascript
const name = "名前";
// `name`というプロパティ名で`name`の変数を値に設定したオブジェクト
const obj = {
    name
};
console.log(obj); // => { name: "名前" }
```

## {}はObjectのインスタンスオブジェクト

ObjectはJavaScriptのビルトインオブジェクトです。 オブジェクトリテラル（{}）は、このビルトインオブジェクトであるObjectを元にして新しいオブジェクトを作成するための構文

オブジェクトリテラル以外の方法として、new演算子を使うことで、Objectから新しいオブジェクトを作成でき

```javascript
// プロパティを持たない空のオブジェクトを作成
// = `Object`からインスタンスオブジェクトを作成
const obj = new Object();
console.log(obj); // => {}
```

## プロパティへのアクセス


オブジェクトのプロパティにアクセスする方法として、ドット記法（.）を使う方法とブラケット記法


```javascript
const obj = {
    key: "value"
};
// ドット記法で参照
console.log(obj.key); // => "value"
// ブラケット記法で参照
console.log(obj["key"]); // => "value"
```


```javascript
obj.key; // OK
// プロパティ名が数字から始まる識別子は利用できない
obj.123; // NG
// プロパティ名にハイフンを含む識別子は利用できない
obj.my-prop; // NG
```
ブラケット記法では、[と]の間に任意の式を書ける

```javascript
const obj = {
    key: "value",
    123: 456,
    "my-key": "my-value"
};

console.log(obj["key"]); // => "value"
// プロパティ名が数字からはじまる識別子も利用できる
console.log(obj[123]); // => 456
// プロパティ名は暗黙的に文字列に変換されているため、次も同じプロパティを参照している
console.log(obj["123"]); // => 456
// プロパティ名にハイフンを含む識別子も利用できる
console.log(obj["my-key"]); // => "my-value"
```


ブラケット記法ではプロパティ名に変数も利用できます。 次のコードでは、プロパティ名にmyLangという変数をブラケット記法で指定しています。

```javascript
const languages = {
    ja: "日本語",
    en: "英語"
};
const myLang = "ja";
```


オブジェクトと分割代入

同じオブジェクトのプロパティに何度もアクセスする場合に、何度もオブジェクト.プロパティ名と書くと冗長となりやすいから、短い名前で利用できるように、そのプロパティを変数として定義し直すことがある

```javascript
const languages = {
    ja: "日本語",
    en: "英語"
};
const ja = languages.ja;
const en = languages.en;
console.log(ja); // => "日本語"
console.log(en); // => "英語"
```

このようにオブジェクトのプロパティを変数として定義し直すときには、分割代入（Destructuring assignment）が利用でき

```javascript
const languages = {
    ja: "日本語",
    en: "英語"
};
const { ja, en } = languages;
console.log(ja); // => "日本語"
console.log(en); // => "英語"
```

プロパティの追加

```javascript
// 空のオブジェクト
const obj = {};
// `key`プロパティを追加して値を代入
obj.key = "value";
console.log(obj.key); // => "value"
```

ブラケット記法はobject[式]の式の評価結果を文字列にしたものをプロパティ名として利用できる

```javascript
const key = "key-string";
const obj = {};
// `key`の評価結果 "key-string" をプロパティ名に利用
obj[key] = "value of key";
// 取り出すときも同じく`key`変数を利用
console.log(obj[key]); // => "value of key"
```

コード解説

オブジェクト `obj` に `"key-string"` という名前のプロパティを新しく作って、そこに `"value of key"` を入れてるという意味

```js
const key = "key-string";
const obj = {};
```

`key` には文字列 `"key-string"` が入ってる
`obj` は空のオブジェクト `{}`

```js
obj[key] = "value of key";
```

`key` の中身は `"key-string"` だから、これは実質こう

```js
obj["key-string"] = "value of key";
```

つまり `obj` はこうなる

```js
{ "key-string": "value of key" }
```

```js
console.log(obj[key]);
```

これも実質こう

```js
console.log(obj["key-string"]);
```


ブラケット記法を用いたプロパティ定義は、オブジェクトリテラルの中でも利用できる

```javascript
const key = "key-string";
// Computed Propertyで`key`の評価結果 "key-string" をプロパティ名に利用
const obj = {
    [key]: "value"
};
console.log(obj[key]); // => "value"
```

プロパティの削除
オブジェクトのプロパティを削除するにはdelete演算子を利用する、削除したいプロパティをdelete演算子の右辺に指定して、プロパティを削除できる

```javascript
const obj = {
    key1: "value1",
    key2: "value2"
};
// key1プロパティを削除
delete obj.key1;
// key1プロパティが削除されている
console.log(obj); // => { "key2": "value2" }
```

 constで定義したオブジェクトは変更可能
先ほどのコード例で、constで宣言したオブジェクトのプロパティがエラーなく変更できていることがわかります。 次のコードを実行してみると、値であるオブジェクトのプロパティが変更できていることがわかります。

```javascript
const obj = { key: "value" };
obj.key = "Hi!"; // constで定義したオブジェクト(`obj`)が変更できる
console.log(obj.key); // => "Hi!"
```
JavaScriptのconstは値を固定するのではなく、変数への再代入を防ぐためのもの

作成したオブジェクトのプロパティの変更を防止するにはObject.freeze静的メソッドを利用する

```javascript
"use strict";
const object = Object.freeze({ key: "value" });
// freezeしたオブジェクトにプロパティを追加や変更できない
object.key = "value"; // => TypeError: "key" is read-only
```

JavaScriptでは存在しないプロパティへアクセスした場合に例外が発生しません。 プロパティ名を間違えた場合に単にundefinedという値を返すため、間違いに気づきにくいという問題がある

```javascript
const widget = {
    window: {
        title: "ウィジェットのタイトル"
    }
};
// `window`を`windw`と間違えているが、例外は発生しない
console.log(widget.windw); // => undefined
// さらにネストした場合に、例外が発生する
// `undefined.title`と書いたのと同じ意味となるため
console.log(widget.windw.title); // => TypeError: widget.windw is undefined
// 例外が発生した文以降は実行されません
```

プロパティを持っているかを確認する方法として、次の4つがあります。

undefinedとの比較
in演算子
Object.hasOwn静的メソッド
Object.prototype.hasOwnPropertyメソッド

プロパティの存在確認: undefinedとの比較

存在しないプロパティへアクセスした場合にundefinedを返すため、実際にプロパティアクセスすることでも判定できそうです。 次のコードでは、keyプロパティの値がundefinedではないという条件式で、プロパティが存在するかを判定しています。

```javascript
const obj = {
    key: "value"
};
// `key`プロパティが`undefined`ではないなら、プロパティが存在する?
if (obj.key !== undefined) {
    // `key`プロパティが存在する?ときの処理
    console.log("`key`プロパティの値は`undefined`ではない");
}
```
しかし、この方法はプロパティの値がundefinedであった場合に、プロパティそのものが存在するかを区別できないという問題がある

プロパティが存在するかを判定するにはin演算子かObject.hasOwn静的メソッドを利用

プロパティの存在確認: in演算子を使う

in演算子は、指定したオブジェクト上に指定したプロパティがあるかを判定し真偽値を返します。

"プロパティ名" in オブジェクト; // true or false
次のコードではobjにkeyプロパティが存在するかを判定しています。 in演算子は、プロパティの値は関係なく、プロパティが存在した場合にtrueを返します。

```javascript
const obj = { key: undefined };
// `key`プロパティを持っているならtrue
if ("key" in obj) {
    console.log("`key`プロパティは存在する");
}
```
プロパティの存在確認: Object.hasOwn静的メソッド

Object.hasOwn静的メソッドは、対象のオブジェクトが指定したプロパティを持っているかを判定できる

```javascript
const obj = {};
// objが"プロパティ名"を持っているかを確認する
Object.hasOwn(obj, "プロパティ名"); // true or false
```

Optional chaining演算子（?.）

深い（ネストした）プロパティに安全にアクセスするための仕組み

何が問題だったのか

widget.window.title みたいにネストしているとき、widget.window が 存在しない（undefined） 可能性がある。その状態で widget.window.title を読もうとすると、実質こうなる
```javascript
undefined.title
```

これは 例外（TypeError） になる。
だから昔はこうやって「順番に存在確認」してた：
```javascript
if (widget.window !== undefined && widget.window.title !== undefined) {
  ...
}
```

でも、ネストが深くなるほど && が増えて冗長になる。

そこでOptional chaining（?.）を使う

「左側が null または undefined なら、その時点で止めて undefined を返す」 演算子。

ドット . の代わりに ?. を使う。

```javascript
obj?.a?.b
```
挙動のイメージ

obj が null/undefined → そこで止まって undefined
obj はあるけど obj.a が undefined → そこで止まって undefined
obj.a.b まで存在する → その値を返す

つまり 存在しないプロパティを読んでも落ちない（例外にならない）。

?. と ?? の組み合わせが気持ちいい理由

?. は安全にアクセスできても、結果は undefined になることがある。

そこで ??（Nullish coalescing）を使うと、

左が null or undefined なら右を採用

それ以外（空文字 "" や 0 はそのまま）なら左を採用

```javascript
const title = widget?.window?.title ?? "未定義";
```

toStringメソッド
オブジェクトのtoStringメソッドは、オブジェクト自身を文字列化するメソッド
```javascript
const obj = { key: "value" };
console.log(obj.toString()); // => "[object Object]"
// `String`コンストラクタ関数は`toString`メソッドを呼んでいる
console.log(String(obj)); // => "[object Object]"
```

オブジェクトの列挙
最初に紹介したように、オブジェクトはプロパティの集合です。 そのオブジェクトのプロパティを列挙する方法として、次の3つの静的メソッド

Object.keys静的メソッド: オブジェクトのプロパティ名の配列にして返す
Object.values静的メソッド: オブジェクトの値の配列にして返す
Object.entries静的メソッド: オブジェクトのプロパティ名と値の配列の配列を返す

```javascript
const obj = {
    "one": 1,
    "two": 2,
    "three": 3
};
// `Object.keys`はキーを列挙した配列を返す
console.log(Object.keys(obj)); // => ["one", "two", "three"]
// `Object.values`は値を列挙した配列を返す
console.log(Object.values(obj)); // => [1, 2, 3]
// `Object.entries`は[キー, 値]の配列を返す
console.log(Object.entries(obj)); // => [["one", 1], ["two", 2], ["three", 3]]
```

これらのプロパティを列挙する静的メソッドと配列のforEachメソッドなどを組み合わせれば、プロパティに対して反復処理ができる

```javascript
const obj = {
    "one": 1,
    "two": 2,
    "three": 3
};
const keys = Object.keys(obj);
keys.forEach(key => {
    console.log(key);
});
// 次の値が順番に出力される
// "one"
// "two"
// "three"
```

## オブジェクトのマージと複製
Object.assign静的メソッド[ES2015]は、あるオブジェクトを別のオブジェクトに代入（assign）できる

Object.assign静的メソッドは、targetオブジェクトに対して、1つ以上のsourcesオブジェクトを指定する。 sourcesオブジェクト自身が持つ列挙可能なプロパティを第一引数のtargetオブジェクトに対してコピーする、Object.assign静的メソッドの返り値は、targetオブジェクトになる

```javascript
const obj = Object.assign(target, ...sources);
```

オブジェクトのマージ
```javascripta
const objectA = { a: "a" };
const objectB = { b: "b" };
const merged = Object.assign({}, objectA, objectB);
console.log(merged); // => { a: "a", b: "b" }
```

第一引数には空のオブジェクトではなく、既存のオブジェクトも指定できます。 第一引数に既存のオブジェクトを指定した場合は、そのオブジェクトのプロパティが変更

```javascript
const objectA = { a: "a" };
const objectB = { b: "b" };
const merged = Object.assign(objectA, objectB);
console.log(merged); // => { a: "a", b: "b" }
// `objectA`が変更されている
console.log(objectA); // => { a: "a", b: "b" }
console.log(merged === objectA); // => true
```

プロパティ名が重複した時の処理
```javascript
// `version`のプロパティ名が被っている
const objectA = { version: "a" };
const objectB = { version: "b" };
const merged = Object.assign({}, objectA, objectB);
// 後ろにある`objectB`のプロパティで上書きされる
console.log(merged); // => { version: "b" }
```

オブジェクトのspread構文でのマージ

オブジェクトのspread構文は、Object.assignとは異なり必ず新しいオブジェクトを作成
```javascript
const objectA = { a: "a" };
const objectB = { b: "b" };
const merged = {
    ...objectA,
    ...objectB
};
console.log(merged); // => { a: "a", b: "b" }
```

プロパティ名が被った場合の優先順位は、後ろにあるオブジェクトが優先される

オブジェクトの複製
```javascript
// 引数の`obj`を浅く複製したオブジェクトを返す
const shallowClone = (obj) => {
    return Object.assign({}, obj);
};
const obj = { a: "a" };
const cloneObj = shallowClone(obj);
console.log(cloneObj); // => { a: "a" }
// オブジェクトを複製しているので、異なるオブジェクトとなる
console.log(obj === cloneObj); // => false
```

注意点として、Object.assign静的メソッドはsourcesオブジェクトのプロパティを浅くコピー（shallow copy）する点です。 shallow copyとは、sourcesオブジェクトの直下にあるプロパティだけをコピーするということです。 そのプロパティの値がオブジェクトである場合に、ネストした先のオブジェクトまでも複製するわけではありません。

```javascript
const shallowClone = (obj) => {
    return Object.assign({}, obj);
};
const obj = {
    level: 1,
    nest: {
        level: 2
    },
};
const cloneObj = shallowClone(obj);
// `nest`プロパティのオブジェクトは同じオブジェクトのままになる 
console.log(cloneObj.nest === obj.nest); // => true

逆にプロパティの値までも再帰的に複製してコピーすることを、深いコピー（deep copy）と呼びます。 deep copyは、再帰的にshallow copyすることで実現

// 引数の`obj`を浅く複製したオブジェクトを返す
const shallowClone = (obj) => {
    return Object.assign({}, obj);
};
// 引数の`obj`を深く複製したオブジェクトを返す
function deepClone(obj) {
    const newObj = shallowClone(obj);
    // プロパティがオブジェクト型であるなら、再帰的に複製する
    Object.keys(newObj)
        .filter(k => typeof newObj[k] === "object")
        .forEach(k => newObj[k] = deepClone(newObj[k]));
    return newObj;
}
const obj = {
    level: 1,
    nest: {
        level: 2
    }
};
const cloneObj = deepClone(obj);
// `nest`オブジェクトも再帰的に複製されている
console.log(cloneObj.nest === obj.nest); // => false
```

プロトタイプオブジェクト

Objectはすべての元
Objectには、他のArray、String、Functionなどのオブジェクトとは異なる特徴があります。 それは、他のオブジェクトはすべてObjectを継承しているという点
```javascript
// `Object.prototype`オブジェクトに`toString`メソッドの定義がある
console.log(typeof Object.prototype.toString); // => "function"
```
```javascript
const obj = {
    "key": "value"
};
// `obj`インスタンスは`Object.prototype`に定義されたものを継承する
// `obj.toString`は継承した`Object.prototype.toString`を参照している
console.log(obj.toString === Object.prototype.toString); // => true
// インスタンスからプロトタイプメソッドを呼び出せる
console.log(obj.toString()); // => "[object Object]"

```

このインスタンスからprototypeオブジェクト上に定義されたメソッドを参照できる仕組みをプロトタイプチェーン

プロトタイプメソッドとインスタンスメソッドの優先順位

プロトタイプメソッドよりも優先してインスタンスのメソッドが呼び出されている
```javascript
// オブジェクトのインスタンスにtoStringメソッドを定義
const customObject = {
    toString() {
        return "custom value";
    }
};
console.log(customObject.toString()); // => "custom value"

```

Object.hasOwn静的メソッドとin演算子との違い

Object.hasOwn静的メソッドは、指定したオブジェクト自体が指定したプロパティを持っているかを判定します。 一方、in演算子はオブジェクト自身が持っていなければ、そのオブジェクトの継承元であるprototypeオブジェクトまで探索して持っているかを判定

```javascript
const obj = {};
// `obj`というオブジェクト自体に`toString`メソッドが定義されているわけではない
console.log(Object.hasOwn(obj, "toString")); // => false
// `in`演算子は指定されたプロパティ名が見つかるまで親をたどるため、`Object.prototype`まで見にいく
console.log("toString" in obj); // => true
```

オブジェクトの継承元を明示するObject.create静的メソッド

Object.create静的メソッドを使うと、第一引数に指定したprototypeオブジェクトを継承した新しいオブジェクトを作成できる

```javascript
// const obj = {} と同じ意味
const obj = Object.create(Object.prototype);
// `obj`は`Object.prototype`を継承している
// そのため、`obj.toString`と`Object.prototype.toString`は同じとなる
console.log(obj.toString === Object.prototype.toString); // => true
```

ArrayもObjectを継承している

ビルトインオブジェクトArrayもArray.prototypeを持っています。 同じように、配列（Array）のインスタンスはArray.prototypeを継承します。 さらに、Array.prototypeはObject.prototypeを継承しているため、ArrayのインスタンスはObject.prototypeも継承しています。



Arrayのインスタンス → Array.prototype → Object.prototype

Object.prototypeはすべてのオブジェクトの親となるオブジェクトであること

ArrayのインスタンスでtoStringメソッドを呼び出すとArray.prototype.toStringが優先して呼び出される

```javascript
const numbers = [1, 2, 3];
// `Array.prototype.toString`が定義されているため、`Object.prototype.toString`とは異なる出力形式となる
console.log(numbers.toString()); // => "1,2,3"
```

Object.prototypeを継承しないオブジェクト

Object.create(null)とすることでObject.prototypeを継承しないオブジェクトを作成できる

```javascript
// 親がnull、つまり親がいないオブジェクトを作る
const obj = Object.create(null);
// Object.prototypeを継承しないため、hasOwnPropertyが存在しない
console.log(obj.hasOwnProperty); // => undefined
```

配列

配列の作成とアクセス
```javascript
const emptyArray = [];
const numbers = [1, 2, 3];
// 2次元配列（配列の配列）
const matrix = [
    ["a", "b"],
    ["c", "d"]
];
```


2次元配列（配列の配列）からの値の読み取りも同様に配列[インデックス]でアクセスできる

```javascript
// 2次元配列（配列の配列）
const matrix = [
    ["a", "b"],
    ["c", "d"]
];
console.log(matrix[0][0]); // => "a"
```

配列のlengthプロパティは配列の要素の数を返す
```javascript
const array = ["one", "two", "three"];
console.log(array.length); // => 3
// 配列の要素数 - 1 が 最後の要素のインデックスとなる
console.log(array[array.length - 1]); // => "three"
```

一方、存在しないインデックスにアクセスした場合はどうなるでしょうか？ JavaScriptでは、存在しないインデックスに対してアクセスした場合に、例外ではなくundefinedを返します

```javascript
const array = ["one", "two", "three"];
// `array`にはインデックスが100の要素は定義されていない
console.log(array[100]); // => undefined
```

配列の中に隙間があるものを疎な配列と呼びます。 一方、隙間がなくすべてのインデックスに要素がある配列を密な配列

```javascript
// 未定義の箇所が1つ含まれる疎な配列
// インデックスが1の値を省略しているので、カンマが2つ続いていることに注意
const sparseArray = [1, , 3];
console.log(sparseArray.length); // => 3
// 1番目の要素は存在しないため undefined が返る
console.log(sparseArray[1]); // => undefined
```

Array.prototype.at

相対的なインデックスの値を指定して配列の要素へアクセスできる

```javascript
const array = ["a", "b", "c"];
//
console.log(array.at(0)); // => "a"
console.log(array.at(1)); // => "b"
// 後ろから1つ目の要素にアクセス
console.log(array.at(-1)); // => "c"
// -1は、次のように書いた場合と同じ結果
console.log(array[array.length - 1]); // => "c"

```

配列[インデックス]のインデックスに-1を指定すると、配列オブジェクトの"-1"というプロパティ名へのアクセスとなります。 そのため配列[-1]と書くと、大抵の場合はundefinedが返されます。


```javascript
const array = ["a", "b", "c"];
console.log(array[-1]); // => undefined
```
オブジェクトが配列かどうかを判定する

あるオブジェクトが配列かどうかを判定するにはArray.isArray静的メソッドを利用します。 Array.isArray静的メソッドは引数が配列ならばtrueを返します。

```javascript
const obj = {};
const array = [];
console.log(Array.isArray(obj)); // => false
console.log(Array.isArray(array)); // => true
```

typeof演算子では配列かどうかを判定することはできません。 配列もオブジェクトの一種であるため、typeof演算子の結果が"object"となる

配列と分割代入

配列の分割代入では、左辺に配列リテラルのような構文で定義したい変数名を書きます。 右辺の配列から対応するインデックスの要素が、左辺で定義した変数に代入され

```javascript
const array = ["one", "two", "three"];
const [first, second, third] = array;
console.log(first);  // => "one"
console.log(second); // => "two"
console.log(third);  // => "three"
```

配列から要素を検索
配列から指定した要素を検索する目的には、 主に次の3つがあります。

その要素のインデックスが欲しい場合
その要素自体が欲しい場合
その要素が含まれているかという真偽値が欲しい場合

配列にはそれぞれに対応したメソッドが用意されている

インデックスを取得

ArrayのindexOfメソッドを利用して、配列の中から"JavaScript"という文字列のインデックスを取得しています。 indexOfメソッドは引数と厳密等価演算子（===）で一致する要素を先頭から検索して該当する要素のインデックスを返し、該当する要素がない場合は-1を返します。 indexOfメソッドには対となるlastIndexOfメソッドがあり、lastIndexOfメソッドでは末尾から検索した結果が得られ

```javascript
const array = ["Java", "JavaScript", "Ruby", "JavaScript"];
// 先頭から探索して最初に見つかった"JavaScript"のインデックスを取得
const indexOfJS = array.indexOf("JavaScript");
console.log(indexOfJS); // => 1
// 末尾から探索して最初に見つかった"JavaScript"のインデックスを取得
const lastIndexOfJS = array.lastIndexOf("JavaScript");
console.log(lastIndexOfJS); // => 3
console.log(array[indexOfJS]); // => "JavaScript"
console.log(array[lastIndexOfJS]); // => "JavaScript"
// "JS" という要素はないため `-1` が返される
console.log(array.indexOf("JS")); // => -1
console.log(array.lastIndexOf("JS")); // => -1
```

indexOfメソッドは配列からプリミティブな要素を発見できますが、オブジェクトは持っているプロパティが同じでも別オブジェクトだと異なるものとして扱われる

```javascript
const obj = { key: "value" };
const array = ["A", "B", obj];
console.log(array.indexOf({ key: "value" })); // => -1
// リテラルは新しいオブジェクトを作るため、異なるオブジェクトだと判定される
console.log(obj === { key: "value" }); // => false
// 等価のオブジェクトを検索してインデックスを返す
console.log(array.indexOf(obj)); // => 2
```

異なるオブジェクトだが値は同じものを見つけたい場合には、ArrayのfindIndexメソッドが利用できます。 findIndexメソッドの引数には配列の各要素をテストする関数をコールバック関数として渡します。

```javascript
// colorプロパティを持つオブジェクトの配列
const colors = [
    { "color": "red" },
    { "color": "green" },
    { "color": "blue" }
];
// `color`プロパティが"blue"のオブジェクトのインデックスを取得
const indexOfBlue = colors.findIndex((obj) => {
    return obj.color === "blue";
});
console.log(indexOfBlue); // => 2
console.log(colors[indexOfBlue]); // => { "color": "blue" }
```

findIndexメソッドでインデックスを取得し、そのインデックスで配列へアクセスすればよいだけ

条件に一致する要素を取得

しかし、findIndexメソッドを使って要素を取得するケースでは、 そのインデックスが欲しいのか、またはその要素自体が欲しいのかがコードとして明確ではありません。

より明確に要素自体が欲しいということを表現するには、Arrayのfindメソッド[ES2015]が使えます。 findメソッドには、findIndexメソッドと同様にテストする関数をコールバック関数として渡します。 findメソッドの返り値は、要素そのものとなり、要素が存在しない場合はundefinedを返します。

```javascript
// colorプロパティを持つオブジェクトの配列
const colors = [
    { "color": "red" },
    { "color": "green" },
    { "color": "blue" }
];
// `color`プロパティが"blue"のオブジェクトを取得
const blueColor = colors.find((obj) => {
    return obj.color === "blue";
});
console.log(blueColor); // => { "color": "blue" }
// 該当する要素がない場合は`undefined`を返す
const whiteColor = colors.find((obj) => {
    return obj.color === "white";
});
console.log(whiteColor); // => undefined
```

findメソッドにも対となるfindLastメソッド[ES2023]があり、findLastメソッドは末尾から検索した結果が得られ

```javascript
// dateとcountプロパティを持つオブジェクトの配列
const records = [
    { date: "2020/12/1", count: 5 },
    { date: "2020/12/2", count: 11 },
    { date: "2020/12/3", count: 9 },
    { date: "2020/12/4", count: 12 },
    { date: "2020/12/5", count: 3 }
];
// 10より大きい`count`プロパティを持つ最初のオブジェクトを取得
const firstRecord = records.find((record) => {
    return record.count > 10;
});
// 10より大きい`count`プロパティを持つ最後のオブジェクトを取得
const lastRecord = records.findLast((record) => {
    return record.count > 10;
});
console.log(firstRecord); // => { date: "2020/12/2", count: 11 }
console.log(lastRecord); // => { date: "2020/12/4", count: 12 }
```



指定範囲の要素を取得

配列から指定範囲の要素を取り出す方法としてArrayのsliceメソッドが利用できます。 sliceメソッドは、第一引数の開始位置から第二引数の終了位置（終了位置の要素は含まない）までの範囲を取り出した新しい配列を返し

```javascript
const array = ["A", "B", "C", "D", "E"];
// インデックス1から4まで(4の要素は含まない)の範囲を取り出す
console.log(array.slice(1, 4)); // => ["B", "C", "D"]
// 第二引数を省略した場合は、第一引数から末尾の要素までを取り出す
console.log(array.slice(1)); // => ["B", "C", "D", "E"]
// マイナスを指定すると後ろから数えた位置となる
console.log(array.slice(-1)); // => ["E"]
// 第一引数と第二引数が同じ場合は、空の配列を返す
console.log(array.slice(1, 1)); // => []
// 第一引数 > 第二引数の場合、常に空配列を返す
console.log(array.slice(4, 1)); // => []

```

真偽値を取得

ArrayのindexOfメソッドを利用し、該当する要素が含まれているかを判定しています。 indexOfメソッドの結果をindexOfJSに代入していますが、含まれているかを判定する以外には利用していません。 

```javascript
const array = ["Java", "JavaScript", "Ruby"];
// `indexOf`メソッドは含まれていないときのみ`-1`を返すことを利用
const indexOfJS = array.indexOf("JavaScript");
if (indexOfJS !== -1) {
    console.log("配列にJavaScriptが含まれている");
    // ... いろいろな処理 ...
    // `indexOfJS`は、含まれているのかの判定以外には利用してない
}
```

Arrayのincludesメソッドを利用

```javascript
const array = ["Java", "JavaScript", "Ruby"];
// `includes`は含まれているなら`true`を返す
if (array.includes("JavaScript")) {
    console.log("配列にJavaScriptが含まれている");
}
```

 Arrayのfindメソッドのようにテストするコールバック関数を利用して真偽値を得るには、Arrayのsomeメソッド

 ```javascript
// colorプロパティを持つオブジェクトの配列
const colors = [
    { "color": "red" },
    { "color": "green" },
    { "color": "blue" }
];
// `color`プロパティが"blue"のオブジェクトがあるかどうか
const isIncludedBlueColor = colors.some((obj) => {
    return obj.color === "blue";
});
console.log(isIncludedBlueColor); // => true
 ```

追加と削除

要素を配列の末尾へ追加するにはArrayのpushが利用できます。 一方、末尾から要素を削除するにはArrayのpopが利用できる

```javascript
const array = ["A", "B", "C"];
array.push("D"); // "D"を末尾に追加
console.log(array); // => ["A", "B", "C", "D"]
const poppedItem = array.pop(); // 最末尾の要素を削除し、その要素を返す
console.log(poppedItem); // => "D"
console.log(array); // => ["A", "B", "C"]
```

要素を配列の先頭へ追加するにはArrayのunshiftが利用できます。 一方、配列の先頭から要素を削除するにはArrayのshiftが利用できる
```javascript
const array = ["A", "B", "C"];
array.unshift("S"); // "S"を先頭に追加
console.log(array); // => ["S", "A", "B", "C"]
const shiftedItem = array.shift(); // 先頭の要素を削除
console.log(shiftedItem); // => "S"
console.log(array); // => ["A", "B", "C"]
```

配列同士を結合

Arrayのconcatメソッドを使うことで配列と配列を結合した新しい配列を作成
```javascript
const array = ["A", "B", "C"];
const newArray = array.concat(["D", "E"]);
console.log(newArray); // => ["A", "B", "C", "D", "E"]
```

concatメソッドは配列だけではなく任意の値を要素として結合できる

```javascript
const array = ["A", "B", "C"];
const newArray = array.concat("新しい要素");
console.log(newArray); // => ["A", "B", "C", "新しい要素"]
```

配列の展開

...（Spread構文）を使うことで、配列リテラル中に既存の配列を展開できる
配列リテラルの末尾に配列を展開しています。 これは、Arrayのconcatメソッドで配列同士を結合するのと同じ結果になり

```javascript
const array = ["A", "B", "C"];
// Spread構文を使った場合
const newArray = ["X", "Y", "Z", ...array];
// concatメソッドの場合
const newArrayConcat = ["X", "Y", "Z"].concat(array);
console.log(newArray); // => ["X", "Y", "Z", "A", "B", "C"]
console.log(newArrayConcat); // => ["X", "Y", "Z", "A", "B", "C"]
```

Spread構文は、concatメソッドとは異なり、配列リテラル中の任意の位置に配列を展開できる

```javascript
const array = ["A", "B", "C"];
const newArray = ["X", ...array, "Z"];
console.log(newArray); // => ["X", "A", "B", "C", "Z"]
```

配列から要素を削除

Array.prototype.splice

 配列の任意のインデックスの要素を削除するにはArrayのspliceメソッドを利用できる

spliceメソッドを利用すると、削除した要素を自動で詰めることができます。 spliceメソッドは指定したインデックスから、指定した数だけ要素を取り除き、必要ならば要素を同時に追加できる

```javascript
const array = [];
array.splice(インデックス, 削除する要素数);
// 削除と同時に要素の追加もできる
array.splice(インデックス, 削除する要素数, ...追加する要素);
```

```javascript
const array = ["a", "b", "c"];
// 1番目から1つの要素("b")を削除
array.splice(1, 1);
console.log(array); // => ["a", "c"]
console.log(array.length); // => 2
console.log(array[1]); // => "c"
// すべて削除
array.splice(0, array.length);
console.log(array.length); // => 0
```

lengthプロパティへの代入

配列のすべての要素を削除することはArrayのspliceで行えますが、 配列のlengthプロパティへの代入を利用した方法もあります。

const array = [1, 2, 3];
array.length = 0; // 配列を空にする
console.log(array); // => []

空の配列を代入

その配列の要素を削除するのではなく、新しい空の配列を変数へ代入する方法

```javascript
let array = [1, 2, 3];
console.log(array.length); // => 3
// 新しい配列で変数を上書き
array = [];
console.log(array.length); // => 0

```

破壊的なメソッドと非破壊的なメソッド

破壊的なメソッド（Mutable Method）とは、配列オブジェクトそのものを変更し、変更した配列または変更箇所を返すメソッドです。 非破壊的メソッド（Immutable Method）とは、配列オブジェクトのコピーを作成してから変更し、そのコピーした配列を返すメソッドです。

```javascript:破壊的メソッド例
const myArray = ["A", "B", "C"];
const result = myArray.push("D");
// `push`の返り値は配列ではなく、追加後の配列のlength
console.log(result); // => 4
// `myArray`が参照する配列そのものが変更されている
console.log(myArray); // => ["A", "B", "C", "D"]
```
```非破壊的メソッド例
const myArray = ["A", "B", "C"];
// `concat`の返り値は結合済みの新しい配列
const newArray = myArray.concat("D");
console.log(newArray); // => ["A", "B", "C", "D"]
// `myArray`は変更されていない
console.log(myArray); // => ["A", "B", "C"]
// `newArray`と`myArray`は異なる配列オブジェクト
console.log(myArray === newArray); // => false
```

破壊的メソッド

```javascript
メソッド名	返り値
Array.prototype.pop	配列の末尾の値
Array.prototype.push	変更後の配列のlength
Array.prototype.splice	取り除かれた要素を含む配列
Array.prototype.reverse	反転した配列
Array.prototype.shift	配列の先頭の値
Array.prototype.sort	ソートした配列
Array.prototype.unshift	変更後の配列のlength
Array.prototype.copyWithin[ES2015]	変更後の配列
Array.prototype.fill[ES2015]	変更後の配列
```

JavaScriptにはcopyメソッドそのものは存在しませんが、配列をコピーする方法としてArrayのsliceメソッドとconcatメソッドが利用されています。 sliceメソッドとconcatメソッドは引数なしで呼び出すと、その配列のコピーを返します。

```javascript
const myArray = ["A", "B", "C"];
// `slice`は`myArray`のコピーを返す - `myArray.concat()`でも同じ
const copiedArray = myArray.slice();
myArray.push("D");
console.log(myArray); // => ["A", "B", "C", "D"]
// `array`のコピーである`copiedArray`には影響がない
console.log(copiedArray); // => ["A", "B", "C"]
// コピーであるため参照は異なる
console.log(copiedArray === myArray); // => false
```

 今まで、破壊的なメソッドしかなかった、splice、reverse、sortに対して、 非破壊的なバージョンであるtoSpliced、toReversed、toSortedが追加されました。


 ```javascript
const array = ["A", "B", "C"];
// `toSpliced`は`array`を複製してから変更する
const newArray = array.toSpliced(1, 1);
console.log(newArray); // => ["A", "C"]
// コピー元の`array`には影響がない
console.log(array); // => ["A", "B", "C"]
 ```

配列の指定したインデックスの要素を非破壊的に変更するwithメソッドも追加されました。 array[index] = valueの代入処理は、元々の配列を変更する破壊的な処理です。 これに対してwithメソッドは、配列を複製してから指定したインデックスの要素を変更した配列を返す非破壊的なメソッド

```javascript
const array = ["A", "B", "C"];
// `array`の1番目の要素を変更した配列を返す
const newArray = array.with(1, "B2");
console.log(newArray); // => ["A", "B2", "C"]
```

破壊的な方法と非破壊的な方法のまとめ
```javascript
破壊的な方法	非破壊な方法
array[index] = item	Array.prototype.with[ES2023]
Array.prototype.pop	array.slice(0, -1)とarray.at(-1)[ES2022]
Array.prototype.push	[...array, item][ES2015]
Array.prototype.splice	Array.prototype.toSpliced[ES2023]
Array.prototype.reverse	Array.prototype.toReversed[ES2023]
Array.prototype.sort	Array.prototype.toSorted[ES2023]
Array.prototype.shift	array.slice(1)とarray.at(0)[ES2022]
Array.prototype.unshift	[item, ...array][ES2015]
Array.prototype.copyWithin[ES2015]	なし
Array.prototype.fill[ES2015]	なし
```

配列を反復処理するメソッド

Array.prototype.forEach
ArrayのforEachメソッドは配列の要素を先頭から順番にコールバック関数へ渡し、反復処理を行うメソッド

```javascript
const array = [1, 2, 3];
array.forEach((currentValue, index, array) => {
    console.log(currentValue, index, array);
});
// コンソールの出力
// 1, 0, [1, 2, 3]
// 2, 1, [1, 2, 3]
// 3, 2, [1, 2, 3]
```
Array.prototype.map

Arrayのmapメソッドは配列の要素を順番にコールバック関数へ渡し、コールバック関数が返した値から新しい配列を返す非破壊的なメソッド

```javascript
// 各要素に10を乗算した新しい配列を作成する
const newArray = array.map((currentValue, index, array) => {
    return currentValue * 10;
});
console.log(newArray); // => [10, 20, 30]
// 元の配列とは異なるインスタンス
console.log(array === newArray); // => false
```

Array.prototype.filter


Arrayのfilterメソッドは配列の要素を順番にコールバック関数へ渡し、コールバック関数がtrueを返した要素だけを集めた新しい配列を返す非破壊的なメソッド、配列から不要な要素を取り除いた配列を作成したい場合に利用

```javascript
const array = [1, 2, 3];
// 奇数の値を持つ要素だけを集めた配列を返す
const newArray = array.filter((currentValue, index, array) => {
    return currentValue % 2 === 1;
});
console.log(newArray); // => [1, 3]
// 元の配列とは異なるインスタンス
console.log(array === newArray); // => false
```

Array.prototype.reduce

Arrayのreduceメソッドは累積値（アキュムレータ）と配列の要素を順番にコールバック関数へ渡し、1つの累積値を返します。 配列から配列以外を含む任意の値を作成したい場合に利用、reduceメソッドの第二引数には累積値の初期値となる値を渡せる

```javascript
const array = [1, 2, 3];
// すべての要素を加算した値を返す
// accumulatorの初期値は`0`
const totalValue = array.reduce((accumulator, currentValue, index, array) => {
    return accumulator + currentValue;
}, 0);
// 0 + 1 + 2 + 3という式の結果が返り値になる
console.log(totalValue); // => 6
```

reduceメソッドに渡したコールバック関数は配列の要素数である3回呼び出され、それぞれ次のような結果になります。

```javascript
accumulator	currentValue	returnした値
1回目の呼び出し	0	1	0 + 1
2回目の呼び出し	1	2	1 + 2
3回目の呼び出し	3	3	3 + 3
```

配列の数値の合計をforEachメソッドなど反復処理で計算すると、次のコードのようにtotalValueという変数は再代入ができるletで宣言する必要があります。


const array = [1, 2, 3];
// 初期値は`0`
let totalValue = 0;
array.forEach((currentValue) => {
    totalValue += currentValue;
});
console.log(totalValue); // => 6
実行
letで宣言した変数は再代入が可能なため、意図しない箇所で変数の値が変更され、バグの原因となることがあります。 そのため、できる限り変数をconstで宣言したい場合にはreduceメソッドは有用です。 一方で、reduceメソッドは可読性があまりよくないため、コードの意図が伝わりにくいというデメリットもあります。

```javascript
const array = [1, 2, 3];
function sum(array) {
    return array.reduce((accumulator, currentValue) => {
        return accumulator + currentValue;
    }, 0);
}
console.log(sum(array)); // => 6
```

Array.prototype.flatメソッド

Arrayのflatメソッド[ES2019]を使うことで、多次元配列をフラットな配列に変換できる

```javascript
const array = [[["A"], "B"], "C"];
// 引数なしは1を指定した場合と同じ
console.log(array.flat()); // => [["A"], "B", "C"]
console.log(array.flat(1)); // => [["A"], "B", "C"]
console.log(array.flat(2)); // => ["A", "B", "C"]
// すべてをフラット化するにはInfinityを渡す
console.log(array.flat(Infinity)); // => ["A", "B", "C"]
```

Arrayのflatメソッドは必ず新しい配列を作成して返すメソッドです。 そのため、これ以上フラット化できない配列をフラット化しても、同じ要素を持つ新しい配列を返す

```javascript
const array = ["A", "B", "C"];
console.log(array.flat()); // => ["A", "B", "C"]
```

メソッドチェーンと高階関数

 メソッドチェーンとは、メソッドを呼び出した返り値に対してさらにメソッド呼び出しをするパターンのこと

```javascript
const array = ["a"].concat("b").concat("c");
console.log(array); // => ["a", "b", "c"]
```

concatメソッドの返り値は結合した新しい配列です。先ほどのメソッドチェーンでは、その新しい配列に対してさらにconcatメソッドで値を結合しているということ

```javascript
// メソッドチェーンを分解した例
// 一時的な`abArray`という変数が増えている
const abArray = ["a"].concat("b");
console.log(abArray); // => ["a", "b"]
const abcArray = abArray.concat("c");
console.log(abcArray); // => ["a", "b", "c"]
```

配列から2000年以前に発行されたECMAScriptのバージョン名の一覧を取り出すことを考えてみます。目的の一覧を取り出すには「2000年以前のデータに絞り込む」と「データからnameを取り出す」という2つの加工処理を組み合わせる必要がある

```javascript
// ECMAScriptのバージョン名と発行年
const ECMAScriptVersions = [
    { name: "ECMAScript 1", year: 1997 },
    { name: "ECMAScript 2", year: 1998 },
    { name: "ECMAScript 3", year: 1999 },
    { name: "ECMAScript 5", year: 2009 },
    { name: "ECMAScript 5.1", year: 2011 },
    { name: "ECMAScript 2015", year: 2015 },
    { name: "ECMAScript 2016", year: 2016 },
    { name: "ECMAScript 2017", year: 2017 },
];
// メソッドチェーンで必要な加工処理を並べている
const versionNames = ECMAScriptVersions
    // 2000年以下のデータに絞り込み
    .filter(ECMAScript => ECMAScript.year <= 2000)
    // それぞれの要素から`name`プロパティを取り出す
    .map(ECMAScript => ECMAScript.name);
console.log(versionNames); // => ["ECMAScript 1", "ECMAScript 2", "ECMAScript 3"]
```

文字列

文字列を作成する

文字列リテラルには"（ダブルクォート）、'（シングルクォート）、`（バッククォート）の3種類があり

```javascript
const double = "文字列";
console.log(double); // => "文字列"
const single = '文字列';
console.log(single); // => '文字列'
// どちらも同じ文字列
console.log(double === single);// => true
```

エスケープシーケンス

文字列リテラル中にはそのままでは入力できない特殊な文字

```javascript
エスケープシーケンス	意味
\'	シングルクォート
\"	ダブルクォート
\` 	バッククォート
\\	バックスラッシュ(\そのものを表示する)
\n	改行
\t	タブ
\uXXXX	Code Unit(\uと4桁のHexDigit)
\u{X} ... \u{XXXXXX}	Code Point（\u{}のカッコ中にHexDigit）
```

先ほどの"（ダブルクォート）の中に改行（\n）を入力できる

```javascript
// 改行を\nのエスケープシーケンスとして入力している
const multiline = "1行目\n2行目\n3行目";
console.log(multiline); 
/* 改行した結果が出力される
1行目
2行目
3行目
*/
```

文字列を結合する

```javascript
const str = "a" + "b";
console.log(str); // => "ab"
```

特定の書式に文字列を埋め込むには、テンプレートリテラルを使うとより宣言的に書けます。

テンプレートリテラル中に${変数名}で書かれた変数は評価時に展開されます。 つまり、先ほどの文字列結合は次のように書けます。

```javascript
const name = "JavaScript";
console.log(`Hello ${name}!`);// => "Hello JavaScript!"
```

文字へのアクセス

```javascript
const str = "文字列";
// 配列と同じようにインデックスでアクセスできる
console.log(str[0]); // => "文"
console.log(str[1]); // => "字"
console.log(str[2]); // => "列"
```

存在しないインデックスへのアクセスでは配列やオブジェクトと同じようにundefinedを返す

```javascript
const str = "文字列";
// 42番目の要素は存在しない
console.log(str[42]); // => undefined
```

String.prototype.at

String.prototype.atメソッドが追加されています。 Stringのatメソッドは、Arrayのatメソッドと同じく、相対的なインデックスを渡してその位置の文字へアクセスできる

```javascript
const str = "文字列";
console.log(str.at(0)); // => "文"
console.log(str.at(1)); // => "字"
console.log(str.at(2)); // => "列"
console.log(str.at(-1)); // => "列"
```

文字列の分解と結合

文字列を配列へ分解するにはStringのsplitメソッドを利用でき、配列の要素を結合して文字列にするにはArrayのjoinメソッドを利用できる,
この２つを合わせれば、区切り文字を・から、へ変換する処理が可能

```javascript
const strings = "赤・青・緑".split("・");
console.log(strings); // => ["赤", "青", "緑"]
```

Stringのsplitメソッドの第一引数には正規表現も指定でき

```javascript
// 文字間に1つ以上のスペースがある
const str = "a     b    c      d";
// 1つ以上のスペースにマッチして分解する
const strings = str.split(/\s+/);
console.log(strings); // => ["a", "b", "c", "d"]
```

文字列の長さ

文字列は3つの要素（Code Unit）が並んだものであるため、lengthプロパティは3を返す
```javascript
console.log("文字列".length); // => 3
```

空文字列は要素数が0であるため、lengthプロパティの結果も0となる
```javascript
console.log("".length); // => 0
```

文字列の比較
文字列の比較には===（厳密比較演算子）を利用し

```javascript
console.log("文字列" === "文字列"); // => true
// 一致しなければfalseとなる
console.log("JS" === "ES"); // => false
// 文字列の長さが異なるのでfalseとなる
console.log("文字列" === "文字"); // => false
```

文字列の一部を取得

Stringのsliceメソッドやsubstringメソッドが利用できます

```javascript
const str = "ABCDE";
console.log(str.slice(1)); // => "BCDE"
console.log(str.slice(1, 5)); // => "BCDE"
// マイナスを指定すると後ろからの位置となる
console.log(str.slice(-1)); // => "E"
// インデックスが1から4の範囲を取り出す
console.log(str.slice(1, 4)); // => "BCD"
// 第一引数 > 第二引数の場合、常に空文字列を返す
console.log(str.slice(4, 1)); // => ""
```

sliceメソッドと同じく第一引数に開始位置、第二引数に終了位置を指定し、その範囲を取り出して新しい文字列を返します。 第二引数を省略した場合の挙動も同様で、省略した場合は文字列の末尾が終了位置となります。

位置にマイナスの値を指定した場合は常に0として扱われる

```javascript
const str = "ABCDE";
console.log(str.substring(1)); // => "BCDE"
console.log(str.substring(1, 5)); // => "BCDE"
// マイナスを指定すると0として扱われる
console.log(str.substring(-1)); // => "ABCDE"
// 位置:1から4の範囲を取り出す
console.log(str.substring(1, 4)); // => "BCD"
// 第一引数 > 第二引数の場合、引数が入れ替わる
// str.substring(1, 4)と同じ結果になる
console.log(str.substring(4, 1)); // => "BCD"
```


Stringのsliceメソッドは、indexOfメソッドなどの位置を取得するものと組み合わせて使うことが多いでしょう。 次のコードでは、?の位置をindexOfメソッドで取得し、それ以降の文字列をsliceメソッドで切り出しています。

```javascript
const url = "https://example.com?param=1";
const indexOfQuery = url.indexOf("?");
const queryString = url.slice(indexOfQuery);
console.log(queryString); // => "?param=1"
```

文字列の検索

文字列の検索方法として、大きく分けて文字列による検索と正規表現による検索がある

文字列によるインデックスの取得

StringのindexOfメソッドとlastIndexOfメソッドは、指定した文字列で検索し、その文字列が最初に現れたインデックスを返します。 これらは配列のArrayのindexOfメソッドと同じで、厳密等価演算子（===）で文字列を検索します。 一致する文字列がない場合は-1を返し

文字列.indexOf("検索文字列"): 先頭から検索し、指定された文字列が最初に現れたインデックスを返す
文字列.lastIndexOf("検索文字列"): 末尾から検索し、指定された文字列が最初に現れたインデックスを返す

```javascript
// 検索対象となる文字列
const str = "にわにはにわにわとりがいる";
// indexOfは先頭から検索しインデックスを返す - "**にわ**にはにわにわとりがいる"
// "にわ"の先頭のインデックスを返すため 0 となる
console.log(str.indexOf("にわ")); // => 0
// lastIndexOfは末尾から検索しインデックスを返す- "にわにはにわ**にわ**とりがいる"
console.log(str.lastIndexOf("にわ")); // => 6
// 指定した文字列が見つからない場合は -1 を返す
console.log(str.indexOf("未知のキーワード")); // => -1
```

文字列にマッチした文字列の取得

```javascript
const str = "JavaScript";
const searchWord = "Script";
const index = str.indexOf(searchWord);
if (index !== -1) {
    console.log(`${searchWord}が見つかりました`);
} else {
    console.log(`${searchWord}は見つかりませんでした`);
}
```

真偽値の取得

String.prototype.startsWith(検索文字列)[ES2015]: 検索文字列が先頭にあるかの真偽値を返す
String.prototype.endsWith(検索文字列)[ES2015]: 検索文字列が末尾にあるかの真偽値を返す
String.prototype.includes(検索文字列)[ES2015]: 検索文字列を含むかの真偽値を返す

```javascript
// 検索対象となる文字列
const str = "にわにはにわにわとりがいる";
// startsWith - 検索文字列が先頭ならtrue
console.log(str.startsWith("にわ")); // => true
console.log(str.startsWith("いる")); // => false
// endsWith - 検索文字列が末尾ならtrue
console.log(str.endsWith("にわ")); // => false
console.log(str.endsWith("いる")); // => true
// includes - 検索文字列が含まれるならtrue
console.log(str.includes("にわ")); // => true
console.log(str.includes("いる")); // => true
```

正規表現オブジェクト

一方で正規表現による検索では、あるパターン（規則性）にマッチするという柔軟な検索

```javascript
// 正規表現リテラルで正規表現オブジェクトを作成
const patternA = /パターン/フラグ;
// `RegExp`コンストラクタで正規表現オブジェクトを作成
const patternB = new RegExp("パターン文字列", "フラグ");
```

正規表現オブジェクトを作成するもうひとつの方法としてRegExpコンストラクタがあります。 RegExpコンストラクタでは、文字列から正規表現オブジェクトを作成できます。

```javascript
const pattern = new RegExp("a+");
```

RegExp.escapeメソッドが追加され、正規表現の特殊文字を安全にエスケープできます。RegExp.escapeメソッドを使うことで、文字列の中に正規表現として意味を持つ特殊文字が含まれていても、自動的にエスケープできます。

```javascript
const escaped = RegExp.escape("+");
console.log(escaped); // \+
```

正規表現による検索

正規表現によるインデックスの取得

StringのindexOfメソッドの正規表現版ともいえるStringのsearchメソッドがあります。 searchメソッドは正規表現のパターンにマッチした箇所のインデックスを返し、マッチする文字列がない場合は-1を返します。

String.prototype.indexOf(検索文字列): 指定された文字列にマッチした箇所のインデックスを返す
String.prototype.search(/パターン/): 指定された正規表現のパターンにマッチした箇所のインデックスを返す
次のコードでは、数字が3つ連続しているかを検索し、該当した箇所のインデックスを返しています。 \dは、1文字の数字（0から9）にマッチする特殊文字です。


正規表現によるマッチした文字列の取得
```javascript
const str = "abc123def";
// 連続した数字にマッチする正規表現
const searchPattern = /\d+/;
const index = str.search(searchPattern); // => 3
// `index` だけではマッチした文字列の長さがわからない
str.slice(index, index + マッチした文字列の長さ); // マッチした文字列は取得できない
```

マッチした文字列を取得するStringのmatchメソッドとmatchAllメソッドが用意されています。 また、これらのメソッドは正規表現のマッチを文字列の最後まで繰り返すgフラグ

マッチした文字列の取得
```javascript
"文字列".match(/パターン/);
```

matchメソッドで検索した結果、正規表現にマッチする文字列がなかった場合はnullを返します。
```javascript
console.log("文字列".match(/マッチしないパターン/)); // => null
```

matchメソッドは正規表現のgフラグなしのパターンで検索した場合、最初にマッチしたものが見つかった時点で検索が終了する

```javascript
const str = "ABC あいう DE えお";
const alphabetsPattern = /[a-zA-Z]+/;
// gフラグなしでは、最初の結果のみを含んだ特殊な配列を返す
const results = str.match(alphabetsPattern);
console.log(results.length); // => 1
// マッチした文字列はインデックスでアクセスできる
console.log(results[0]); // => "ABC"
// マッチした文字列の先頭のインデックス
console.log(results.index); // => 0
// 検索対象となった文字列全体
console.log(results.input); // => "ABC あいう DE えお"
```

matchメソッドは正規表現のgフラグありのパターンで検索した場合、マッチしたすべての文字列を含んだ配列を返す

```javascript
const str = "ABC あいう DE えお";
const alphabetsPattern = /[a-zA-Z]+/g;
// gフラグありでは、すべての検索結果を含む配列を返す
const resultsWithG = str.match(alphabetsPattern);
console.log(resultsWithG.length); // => 2
console.log(resultsWithG[0]); // => "ABC"
console.log(resultsWithG[1]); // => "DE"
// indexとinputはgフラグありの場合は追加されない
console.log(resultsWithG.index); // => undefined
console.log(resultsWithG.input); // => undefined
```

Stringのmatchメソッドの挙動
マッチしない場合は、nullを返す
マッチした場合は、マッチした文字列を含んだ特殊な配列を返す
正規表現のgフラグがある場合は、マッチしたすべての結果を含んだただの配列を返す

 matchAllメソッドは、マッチした結果をIteratorで返します。

```javascript
const str = "ABC あいう DE えお";
const alphabetsPattern = /[a-zA-Z]+/g;
// matchAllはIteratorを返す
const matchesIterator = str.matchAll(alphabetsPattern);
for (const match of matchesIterator) {
    // マッチした要素ごとの情報を含んでいる
    console.log(`match: "${match[0]}", index: ${match.index}, input: "${match.input}"`);
}
// 次の順番でコンソールに出力される
// match: "ABC", index: 0, input: "ABC あいう DE えお"
// match: "DE", index: 8, input: "ABC あいう DE えお"
```

マッチした文字列の一部を取得
const [マッチした全体の文字列, キャプチャ1, キャプチャ2] = 文字列.match(/パターン(キャプチャ1)と(キャプチャ2)/);

// "ECMAScript (数字+)"にマッチするが、欲しい文字列は数字の部分のみ
const pattern = /ECMAScript (\d+)/;
// 返り値は0番目がマッチした全体、1番目がキャプチャの1番目というように対応している
// [マッチした全部の文字列, キャプチャの1番目, キャプチャの2番目 ....]
const [all, capture1] = "ECMAScript 6".match(pattern);
console.log(all); // => "ECMAScript 6"
console.log(capture1); // => "6"

matchAllの例
```javascript
// "ES(数字+)"にマッチするが、欲しい文字列は数字の部分のみ
const pattern = /ES(\d+)/g;
// iteratorを返す
const matchesIterator = "ES2015、ES2016、ES2017".matchAll(pattern);
for (const match of matchesIterator) {
    // マッチした要素ごとの情報を含んでいる
    // 0番目はマッチした文字列全体、1番目がキャプチャの1番目である数字
    console.log(`match: "${match[0]}", capture1: ${match[1]}, index: ${match.index}, input: "${match.input}"`);
}
// 次の順番でコンソールに出力される
// match: "ES2015", capture1: 2015, index: 0, input: "ES2015、ES2016、ES2017"
// match: "ES2016", capture1: 2016, index: 7, input: "ES2015、ES2016、ES2017"
// match: "ES2017", capture1: 2017, index: 14, input: "ES2015、ES2016、ES2017"
```

RegExpのexecメソッドはgフラグなしのパターンで検索した場合、マッチした最初の結果のみを含む特殊な配列を返します。 このときのexecメソッドの返り値である配列がindexプロパティとinputプロパティが追加された特殊な配列となるのは、Stringのmatchメソッドと同様

const str = "ABC あいう DE えお";
const alphabetsPattern = /[a-zA-Z]+/;
// gフラグなしでは、最初の結果のみを持つ配列を返す
const results = alphabetsPattern.exec(str);
console.log(results.length); // => 1
console.log(results[0]); // => "ABC"
// マッチした文字列の先頭のインデックス
console.log(results.index); // => 0
// 検索対象となった文字列全体
console.log(results.input); // => "ABC あいう DE えお"


真偽値を取得

正規表現オブジェクトを使って、そのパターンにマッチするかをテストするには、RegExpのtestメソッドを利用

// 検索対象となる文字列
const str = "にわにはにわにわとりがいる";
// ^ - 検索文字列が先頭ならtrue
console.log(/^にわ/.test(str)); // => true
console.log(/^いる/.test(str)); // => false
// $ - 検索文字列が末尾ならtrue
console.log(/にわ$/.test(str)); // => false
console.log(/いる$/.test(str)); // => true
// 検索文字列が含まれるならtrue
console.log(/にわ/.test(str)); // => true
console.log(/いる/.test(str)); // => true
実行

正規表現は柔軟で便利ですが、コード上から意図が消えてしまいやすいです。 そのため、正規表現を扱う際にはコメントや変数名で具体的な意図を補足したほうがよい

文字列の置換/削除

文字列の一部を置換したり削除するにはStringのreplaceメソッドを利用する

delete演算子は文字列に対して利用できません。 strict modeでは、delete演算子で削除できないプロパティを削除しようとするとエラーが発生します。 strict modeでない場合は、エラーも発生せず単に無視される

```javascript
"use strict";
const str = "文字列";
// 文字列の0番目の削除を試みるがStrict modeでは例外が発生する
delete str[0]; // => TypeError: property 0 is non-configurable and can't be deleted
```

Stringのreplaceメソッドで、削除したい文字を取り除いた新しい文字列を返すことで削除を表現します。 replaceメソッドは、文字列から第一引数の検索文字列または正規表現にマッチする部分を、第二引数の置換文字列へ置換する

```javascript
文字列.replace("検索文字列", "置換文字列");
文字列.replace(/パターン/, "置換文字列");
```

replaceメソッドで削除したい部分を空文字列へ置換することで、文字列を削除できる

```javascript
const str = "文字列";
// "文字"を""（空文字列）へ置換することで"削除"を表現
const newStr = str.replace("文字", "");
console.log(newStr); // => "列"
```

replaceメソッドには正規表現も指定できます。 gフラグを有効化した正規表現を渡すことで、文字列からパターンにマッチするものをすべて置換

```javascript
// 検索対象となる文字列
const str = "にわにはにわにわとりがいる";
// 文字列を指定した場合は、最初に一致したものだけが置換される
console.log(str.replace("にわ", "niwa")); // => "niwaにはにわにわとりがいる"
// `g`フラグなし正規表現の場合は、最初に一致したものだけが置換される
console.log(str.replace(/にわ/, "niwa")); // => "niwaにはにわにわとりがいる"
// `g`フラグあり正規表現の場合は、繰り返し置換を行う
console.log(str.replace(/にわ/g, "niwa")); // => "niwaにはniwaniwaとりがいる"
```

replaceメソッドでは、最初に一致したものだけが置換されますが、replaceAllメソッドでは一致したものがすべて置換される

```javascript
// 検索対象となる文字列
const str = "???";
// replaceメソッドに文字列を指定した場合は、最初に一致したものだけが置換される
console.log(str.replace("?", "!")); // => "!??"
// replaceAllメソッドに文字列を指定した場合は、一致したものがすべて置換される
console.log(str.replaceAll("?", "!")); // => "!!!"
// replaceメソッドに正規表現を渡す場合、正規表現の特殊文字はエスケープが必要
console.log(str.replace(/\?/g, "!")); // => "!!!"
// RegExp.escapeとreplaceメソッドを使った場合（ES2025）
console.log(str.replace(new RegExp(RegExp.escape("?"), "g"), "!")); // => "!!!"
// replaceAllメソッドにも正規表現を渡せるが、この場合もエスケープが必要（replaceと同様）
console.log(str.replaceAll(/\?/g, "!")); // => "!!!"
```

replaceメソッドとreplaceAllメソッドでは、キャプチャした文字列を利用して複雑な置換処理
```javascript
const 置換した結果の文字列 = 文字列.replace(/(パターン)/, (all, ...captures) => {
    return 置換したい文字列;
});
```
例として、2017-03-01を2017年03月01日に置換する処理

```javascript
function toDateJa(dateString) {
    // パターンにマッチしたときのみ、コールバック関数で置換処理が行われる
    return dateString.replace(/(\d{4})-(\d{2})-(\d{2})/g, (all, year, month, day) => {
        // `all`には、マッチした文字列全体が入っているが今回は利用しない
        // `all`が次の返す値で置換されるイメージ
        return `${year}年${month}月${day}日`;
    });
}
// マッチしない文字列の場合は、そのままの文字列が返る
console.log(toDateJa("本日ハ晴天ナリ")); // => "本日ハ晴天ナリ"
// マッチした場合は置換した結果を返す
console.log(toDateJa("今日は2017-03-01です")); // => "今日は2017年03月01日です"

```
文字列の組み立て
構造的な文字列を扱う場合は、専用の関数や専用のオブジェクトを作ることで安全に文字列を処理

```javascript
// ベースURLとパスを結合した文字列を返す
function baseJoin(baseURL, pathname) {
    // 末尾に / がある場合は、/ を削除してから結合する
    const stripSlashBaseURL = baseURL.replace(/\/$/, "");
    return stripSlashBaseURL + pathname;
}
// `baseURL`と`pathname`にあるリソースを取得する
function getResource(baseURL, pathname) {
    const url = baseJoin(baseURL, pathname);
    // baseURLの末尾に / があってもなくても同じ結果となる
    console.log(url); // => "http://example.com/resources/example.js"
    // 省略) リソースを取得する処理...
}
const baseURL = "http://example.com/resources/";
const pathname = "/example.js";
getResource(baseURL, pathname);
```

サロゲートペア

サロゲートペアでは、2つのCode Unitの組み合わせ（合計4バイト）で1つの文字（1つのCode Point）を表現
```javascript
// 上位サロゲート + 下位サロゲートの組み合わせ
console.log("\uD867\uDE3D"); // => "𩸽"
// Code Pointでの表現
console.log("\u{29e3d}"); // => "𩸽"
```
```javascript
// 内部的にはCode Unitが並んでいるものとして扱われている
console.log("\uD867\uDE3D"); // => "𩸽"
// インデックスアクセスもCode Unitごととなる
console.log("𩸽"[0]); // => "\uD867"
console.log("𩸽"[1]); // => "\uDE3D"
```
Stringのlengthプロパティは文字列におけるCode Unitの要素数を数えるため、"🍎".lengthの結果は2となる

```javascript
console.log("🍎".length); // => 2
```

正規表現の.とUnicode
```javascript
const [all, fish] = "𩸽のひらき".match(/(.)のひらき/);
console.log(all); // => "\ude3dのひらき"
console.log(fish); // => "\ude3d"
```

正規表現にuフラグをつけます。 uフラグがついた正規表現は、文字列をCode Pointごとに扱います。 そのため、任意の1文字にマッチする.が𩸽という文字（Code Point）にマッチします
```javascript
const [all, fish] = "𩸽のひらき".match(/(.)のひらき/u);
console.log(all); // => "𩸽のひらき"
console.log(fish); // => "𩸽"
```
Code Pointの数を数える
```javascript
// Code Unitの個数を返す
console.log("🍎".length); // => 2
console.log("\uD83C\uDF4E"); // => "🍎"
console.log("\uD83C\uDF4E".length); // => 2
```

JavaScriptには、文字列におけるCode Pointの個数を数えるメソッドは用意されていません。 これを行うには、文字列をCode Pointごとに区切った配列へ変換して、配列の長さを数えるのが簡潔
```javascript
// Code Pointごとの配列にする
// Array.fromメソッドはIteratorを配列にする
const codePoints = Array.from("リンゴ🍎");
console.log(codePoints); // => ["リ", "ン", "ゴ", "🍎"]
// Code Pointの個数を数える
console.log(codePoints.length); // => 4
```
for...ofによる反復処理も文字列をCode Pointごとに扱えます。 これは、for...of文が対象をIteratorとして列挙するため

```javascript
// 指定した`codePoint`の個数を数える
function countOfCodePoints(str, codePoint) {
    let count = 0;
    for (const item of str) {
        if (item === codePoint) {
            count++;
        }
    }
    return count;
}
console.log(countOfCodePoints("🍎🍇🍎🥕🍒", "🍎")); // => 2
```



ラッパーオブジェクト

プリミティブ型のデータのうち、真偽値（Boolean）、数値（Number） 、BigInt、文字列（String）、シンボル（Symbol）にはそれぞれ対応するオブジェクトが存在

```javascript
// "input value"の値をラップしたStringのインスタンスを生成
const str = new String("input value");
// StringのインスタンスメソッドであるtoUpperCaseを呼び出す
str.toUpperCase(); // => "INPUT VALUE"
```

ラッパーオブジェクトとプリミティブ型の対応

ラッパーオブジェクト	プリミティブ型	例
Boolean	真偽値	trueやfalse
Number	数値	1や2
BigInt	BigInt	1nや2n
String	文字列	"文字列"
Symbol	シンボル	Symbol("説明")

注記: undefinedとnullに対応するラッパーオブジェクトはありません。

typeof演算子でラッパーオブジェクトを見ると"object"

```javascript
// プリミティブの文字列は"string"型
const str = "文字列";
console.log(typeof str); // => "string"
// ラッパーオブジェクトは"object"型
const stringWrapper = new String("文字列");
console.log(typeof stringWrapper); // => "object"
```

プリミティブ型の値からラッパーオブジェクトへの自動変換

プリミティブ型の値に対してプロパティアクセスするとき、自動で対応するラッパーオブジェクトに変換される

```javascript
const str = "string";
// プリミティブ型の値に対してメソッド呼び出しを行う
str.toUpperCase();
// `str`へアクセスする際に"string"がラッパーオブジェクトへ変換され、
// ラッパーオブジェクトはStringのインスタンスなのでメソッドを呼び出せる
// つまり、上のコードは下のコードと同じ意味である
(new String(str)).toUpperCase();
```

リテラルを使ったプリミティブ型の文字列とラッパーオブジェクトを使った文字列オブジェクトがあります（真偽値や数値についても同様です）。 この2つを明示的に使い分ける利点はないため、常にリテラルを使うことを推奨

```javascript
// OK: リテラルを使う
const str = "文字列";
// NG: ラッパーオブジェクトを使う
const stringWrapper = new String("文字列");
```

関数とスコープ

スコープとは変数や関数の引数などを参照できる範囲を決めるもの
JavaScriptでは、新しい関数を定義するとその関数にひもづけられた新しいスコープが作成され
関数を定義するということは処理をまとめるというだけではなく、変数が有効な範囲を決める新しいスコープを作っていると言え

スコープとは

スコープとは変数の名前や関数などの参照できる範囲を決めるものです。 スコープの中で定義された変数はスコープの内側でのみ参照でき、スコープの外側からは参照できません。

fn関数のブロック（{と}）内で変数xを定義しています。 この変数xはfn関数のスコープに定義されているため、fn関数の内側では参照できます。 一方、fn関数の外側から変数xは参照できないためReferenceErrorが発生します。

```javascript
function fn() {
    const x = 1;
    // fn関数のスコープ内から`x`は参照できる
    console.log(x); // => 1
}
fn();
// fn関数のスコープ外から`x`は参照できないためエラー
console.log(x); // => ReferenceError: x is not defined
```

関数は仮引数を持てますが、仮引数は関数のスコープにひもづけて定義されます。 そのため、仮引数はその関数の中でのみ参照が可能で、関数の外からは参照できません。

```javascript
function fn(arg) {
    // fn関数のスコープ内から仮引数`arg`は参照できる
    console.log(arg); // => 1
}
fn(1);
// fn関数のスコープ外から`arg`は参照できないためエラー
console.log(arg); // => ReferenceError: arg is not defined
```

関数によるスコープのことを関数スコープと呼ぶ

letやconstは同じスコープ内に同じ名前の変数を二重に定義できないという話をしました。 これは、各スコープには同じ名前の変数は1つしか宣言できないため

```javascript
// スコープ内に同じ"a"を定義すると SyntaxError となる
let a;
let a;
```

スコープが異なれば同じ名前で変数を宣言できる

```javascript
// 異なる関数のスコープには同じ"x"を定義できる
function fnA() {
    let x;
}
function fnB() {
    let x;
}
```

スコープの仕組みがないと、グローバルな空間内で一意な変数名を考える必要があります。 スコープがあることで同じ名前の変数をスコープごとに定義できるため、スコープの役割は重要

ブロックスコープ

{と}で囲んだ範囲をブロックと呼びます。 ブロックもスコープを作成します。 ブロック内で宣言された変数は、スコープ内でのみ参照でき、スコープの外側からは参照できません。

```javascript
// ブロック内で定義した変数はスコープ内でのみ参照できる
{
    const x = 1;
    console.log(x); // => 1
}
// スコープの外から`x`を参照できないためエラー
console.log(x); // => ReferenceError: x is not defined
```

ブロックによるスコープのことをブロックスコープと呼ぶ
if文やwhile文などもブロックスコープを作成します。 単独のブロックと同じく、ブロックの中で宣言した変数は外から参照できません。

```javascript
// if文のブロック内で定義した変数はブロックスコープの中でのみ参照できる
if (true) {
    const x = "inner";
    console.log(x); // => "inner"
}
console.log(x); // => ReferenceError: x is not defined
```

for文は、ループごとに新しいブロックスコープを作成

```javascript
const array = [1, 2, 3, 4, 5];
// ループごとに新しいブロックスコープを作成する
for (const element of array) {
    // forのブロックスコープの中でのみ`element`を参照できる
    console.log(element);
}
// ループの外からはブロックスコープ内の変数は参照できない
console.log(element); // => ReferenceError: element is not defined
```

スコープチェーン


スコープもネストできる
す。 このとき外側のブロックスコープのことをOUTER、内側のブロックスコープのことをINNERと呼ぶとする

```javascript
{
    // OUTERブロックスコープ
    {
        // INNERブロックスコープ
    }
}
```

```javascript
{
    // OUTERブロックスコープ
    const x = "x";
    {
        // INNERブロックスコープからOUTERブロックスコープの変数を参照できる
        console.log(x); // => "x"
    }
}
```

次のようなステップで参照したい変数を探索する

INNERブロックスコープに変数xyzがあるかを確認 => ない
ひとつ外側のOUTERブロックスコープに変数xyzがあるかを確認 => ない
一番外側のスコープにも変数xyzは定義されていない => ReferenceErrorが発生
この内側から外側のスコープへと順番に変数が定義されているか探す仕組みのことをスコープチェーンと呼ぶ

```javascript
 {
    // OUTERブロックスコープ
    const x = "outer";
    {
        // INNERブロックスコープ
        const x = "inner";
        // 現在のスコープ(INNERブロックスコープ)にある`x`を参照する
        console.log(x); // => "inner"
    }
    // 現在のスコープ(OUTERブロックスコープ)にある`x`を参照する
    console.log(x); // => "outer"
}
```

グローバルスコープ

 グローバルスコープとは名前のとおりもっとも外側にあるスコープで、プログラム実行時に暗黙的に作成されます。


```javascript
// プログラム直下はグローバルスコープ
const x = "x";
console.log(x); // => "x"

```

グローバルスコープで定義した変数はグローバル変数と呼ばれ、グローバル変数はあらゆるスコープから参照できる変数となります。 なぜなら、スコープチェーンの仕組みにより、最終的にもっとも外側のグローバルスコープに定義されている変数を参照できるため

```javascript
// グローバル変数はどのスコープからも参照できる
const globalVariable = "グローバル";
// ブロックスコープ
{
    // ブロックスコープ内には該当する変数が定義されてない -> 外側のスコープへ
    console.log(globalVariable); // => "グローバル"
}
// 関数スコープ
function fn() {
    // 関数ブロックスコープ内には該当する変数が定義されてない -> 外側のスコープへ
    console.log(globalVariable); // => "グローバル"
}
fn();
```

ビルトインオブジェクトは、プログラム開始時にグローバルスコープへ自動的に定義されているためどのスコープからも参照できます。

```javascript
// ビルトインオブジェクトは実行環境が自動的に定義している
// どこのスコープから参照してもReferenceErrorにはならない
console.log(isNaN); // => isNaN
console.log(Array); // => Array
```

自分で定義したグローバル変数とビルトインオブジェクトでは、グローバル変数が優先して参照されます。 つまり次のようにビルトインオブジェクトと同じ名前の変数を定義すると、定義した変数が参照されます。

```javascript
// "Array"という名前の変数を定義
const Array = 1;
// 自分で定義した変数がビルトインオブジェクトより優先される
console.log(Array); // => 1

```
ビルトインオブジェクトと同じ名前の変数を定義したことにより、ビルトインオブジェクトを参照できなくなる

このように内側のスコープで外側のスコープと同じ名前の変数を定義することで、外側の変数が参照できなくなることを変数の隠蔽（shadowing）と呼びます。

この問題を回避する方法としては、むやみにグローバルスコープへ変数を定義しないことです。グローバルスコープでビルトインオブジェクトと名前が衝突するとすべてのスコープへ影響を与えますが、関数のスコープ内では影響範囲がその関数の中だけにとどまります。

ビルトインオブジェクトと同じ名前を避けることは難しいです。 なぜならビルトインオブジェクトには実行環境（ブラウザやNode.jsなど）がそれぞれ独自に定義したものが多く存在するためです。 関数などを活用して小さなスコープを中心にしてプログラムを書くことで、ビルトインオブジェクトと同じ名前の変数があっても影響範囲を限定できます。

変数を参照できる範囲を小さくする
```javascript
function doHeavyTask() {
    // 計測したい処理
}
const startTime = Date.now();
doHeavyTask();
const endTime = Date.now();
console.log(`実行時間は${endTime - startTime}ミリ秒`);
```

```javascript
// 実行時間を計測したい関数をコールバック関数として引数に渡す
const measureTask = (taskFn) => {
    const startTime = Date.now();
    taskFn();
    const endTime = Date.now();
    console.log(`実行時間は${endTime - startTime}ミリ秒`);
};
function doHeavyTask() {
    // 計測したい処理
}
measureTask(doHeavyTask);
```

関数スコープとvarの巻き上げ

varとletの挙動
```javascript
let let_x;
var var_x;
// 宣言後にそれぞれの変数を参照すると`undefined`となる
console.log(let_x); // => undefined
console.log(var_x); // => undefined
// 宣言後に値を代入できる
let_x = "letのx";
var_x = "varのx";
```

letとvarで異なる動作

letでは、変数を宣言する前にその変数を参照するとReferenceErrorの例外が発生して参照できません
```javascript
console.log(x); // => ReferenceError: can't access lexical declaration `x' before initialization
let x = "letのx";
```
varでは、変数を宣言する前にその変数を参照してもundefinedとなる
```javascript
// var宣言より前に参照してもエラーにならない
console.log(x); // => undefined
var x = "varのx";
```

varによる変数宣言は、宣言部分が暗黙的にもっとも近い関数またはグローバルスコープの先頭に巻き上げられ、代入部分はそのままの位置に残るという特殊な動作


// 解釈されたコード
// スコープの先頭に宣言部分が巻き上げられる
var x;
console.log(x); // => undefined
// 変数への代入はそのままの位置に残る
x = "varのx";
console.log(x); // => "varのx"


var変数の宣言の巻き上げは、ブロックスコープを無視してもっとも近い関数またはグローバルスコープに変数をひもづけます。 そのため、次のようにブロック{}でvarによる変数宣言を囲んでも、もっとも近い関数スコープであるfn関数の直下に宣言部分が巻き上げられます （if文やfor文におけるブロックスコープも同様に無視されます）。

```javascript
function fn() {
    // 内側のスコープにあるはずの変数`x`が参照できる
    console.log(x); // => undefined
    {
        var x = "varのx";
    }
    console.log(x); // => "varのx"
}
fn();
```
つまり、先ほどのコードは実際の実行時には、次のように解釈されて実行されていると考えられます。

```javascript
// 解釈されたコード
function fn() {
    // もっとも近い関数スコープの先頭に宣言部分が巻き上げられる
    var x;
    console.log(x); // => undefined
    {
        // 変数への代入はそのままの位置に残る
        x = "varのx";
    }
    console.log(x); // => "varのx"
}
fn();
```

この変数の宣言部分がもっとも近い関数またはグローバルスコープの先頭に移動しているように見える動作のことを変数の巻き上げ（hoisting）と呼び

関数宣言と巻き上げ

functionキーワードを使った関数宣言もvarと同様に、もっとも近い関数またはグローバルスコープの先頭に巻き上げられます。

```javascript
// `hello`関数の宣言より前に呼び出せる
hello(); // => "Hello"

function hello(){
    return "Hello";
}
```

関数宣言は宣言そのものであるため、hello関数そのものがスコープの先頭に巻き上げられます

```javascript
// 解釈されたコード
// `hello`関数の宣言が巻き上げられる
function hello(){
    return "Hello";
}

hello(); // => "Hello"
```

varで宣言された変数へ関数を代入した場合はvarのルールで巻き上げら

```javascript
// `hello`変数は巻き上げられ、暗黙的に`undefined`となる
hello(); // => TypeError: hello is not a function

// `hello`変数へ関数を代入している
var hello = function(){
    return "Hello";
};
```

クロージャー

クロージャーとは「外側のスコープにある変数への参照を保持できる」という関数が持つ性質のこと

```javascript
// `increment`関数を定義して返す関数
function createCounter() {
    let count = 0;
    // `increment`関数は`count`変数を参照
    function increment() {
        count = count + 1;
        return count;
    }
    return increment;
}
// `myCounter`は`createCounter`が返した関数を参照
const myCounter = createCounter();
myCounter(); // => 1
myCounter(); // => 2
// 新しく`newCounter`を定義する
const newCounter = createCounter();
newCounter(); // => 1
newCounter(); // => 2
// `myCounter`と`newCounter`は別々の状態を持っている
myCounter(); // => 3
newCounter(); // => 3
```

静的スコープ

printX関数内で変数xを参照していますが、変数xはグローバルスコープと関数runの中で、それぞれ定義されています。 このときprintX関数内のxという識別子がどの変数xを参照するかは静的に決定されます。

```javascript
const x = 10; // ＊1

function printX() {
    // この識別子`x`は常に ＊1 の変数`x`を参照する
    console.log(x); // => 10
}

function run() {
    const x = 20; // ＊2
    printX(); // 常に10が出力される
}

run();
```

スコープチェーンの仕組みを思い出すと、この識別子xは次のように名前解決されてグローバルスコープの変数xを参照することがわかります。

printXの関数スコープに変数xが定義されていない
ひとつ外側のスコープ（グローバルスコープ）を確認する
ひとつ外側のスコープにconst x = 10;が定義されているので、識別子xはこの変数を参照する


クロージャーの用途

関数に状態を持たせる手段として
外から参照できない変数を定義する手段として
グローバル変数を減らす手段として
高階関数の一部分として

```javascript
const createCounter = () => {
    // 外のスコープから`privateCount`を直接参照できない
    let privateCount = 0;
    return () => {
        privateCount++;
        return `${privateCount}回目`;
    };
};
const counter = createCounter();
console.log(counter()); // => "1回目"
console.log(counter()); // => "2回目"
```

関数を返す関数のことを高階関数と呼びますが、クロージャーの性質を使うことで次のようにnより大きいかを判定する高階関数を作れます。 最初からgreaterThan5という関数を定義すればよいのですが、高階関数を使うことで条件を後から定義できるなどの柔軟性があり

```javascript
function greaterThan(n) {
    return function(m) {
        return m > n;
    };
}
// 5より大きな値かを判定する関数を作成する
const greaterThan5 = greaterThan(5);
console.log(greaterThan5(4)); // => false
console.log(greaterThan5(5)); // => false
console.log(greaterThan5(6)); // => true
```

関数とthis

thisの参照先は主に次の条件によって変化します。

実行コンテキストにおけるthis
コンストラクタにおけるthis
関数とメソッドにおけるthis
Arrow Functionにおけるthis

実行コンテキストとthis

スクリプトにおけるthis

実行コンテキストが"Script"である場合、トップレベルのスコープに書かれたthisはグローバルオブジェクトを参照します。 グローバルオブジェクトは、実行環境ごとに異なるものが定義されています。 ブラウザのグローバルオブジェクトはwindowオブジェクト、Node.jsのグローバルオブジェクトはglobalオブジェクトとなります。

ブラウザでは、script要素のtype属性を指定していない場合は、実行コンテキストが"Script"として実行されます。 このscript要素の直下に書いたthisはグローバルオブジェクトであるwindowオブジェクトとなります。

```javascript
<script>
// 実行コンテキストは"Script"
console.log(this); // => window
</script>
```


モジュールにおけるthis

実行コンテキストが"Module"である場合、そのトップレベルのスコープに書かれたthisは常にundefinedとなります。

ブラウザで、script要素にtype="module"属性がついた場合は、実行コンテキストが"Module"として実行されます。 このscript要素の直下に書いたthisはundefinedとなります。
```javascript
<script type="module">
// 実行コンテキストは"Module"
console.log(this); // => undefined
</script>
```

実行環境のグローバルオブジェクトを参照するglobalThis

```javascript
// ブラウザでは`window`オブジェクト、Node.jsでは`global`オブジェクトを参照する
console.log(globalThis);
```

関数とメソッドにおけるthis

関数を定義する方法として、functionキーワードによる関数宣言と関数式、Arrow Functionなどがあります。 thisが参照先を決めるルールは、Arrow Functionとそれ以外の関数定義の方法で異なります。

そのため、まずは関数定義の種類について振り返ってから、それぞれのthisについて見ていき

関数の種類

関数を定義する場合には、次の3つの方法を利用します。

```javascript
// `function`キーワードからはじめる関数宣言
function fn1() {}
// `function`を式として扱う関数式
const fn2 = function() {};
// Arrow Functionを使った関数式
const fn3 = () => {};
```

それぞれ定義した関数は関数名()と書くことで呼び出せます。

```javascript
// 関数宣言
function fn() {}
// 関数呼び出し
fn();
```

メソッドの種類

JavaScriptではオブジェクトのプロパティが関数である場合にそれをメソッドと呼びます。 一般的にはメソッドも含めたものを関数と言い、関数宣言などとプロパティである関数を区別する場合にメソッドと呼びます。

```javascript
const obj = {
    // `function`キーワードを使ったメソッド
    method1: function() {
    },
    // Arrow Functionを使ったメソッド
    method2: () => {
    }
};
```



## 次やること
- 
- 


## 感じたこと
- 

## 学習時間
- 6.80h
