## 取り組んだ課題一覧
- JavaScript Primer

## わかったこと

## 代入

再代入できない
```javascript
const bookTitle = "JavaScript Primer";
bookTitle = "新しいタイトル"; // => TypeError: invalid assignment to const 'bookTitle'
```

再代入できる
```javascript
let bookTitle;
bookTitle = "JavaScript Primer";
```

## データ型
プリミティブ
特徴：イミュータブル
具体例：
真偽値（Boolean）: trueまたはfalseのデータ型
数値（Number）: 42 や 3.14159 などの数値のデータ型
巨大な整数（BigInt）: ES2020から追加された9007199254740992nなどの任意精度の整数のデータ型
文字列（String）: "JavaScript" などの文字列のデータ型
undefined: 値が未定義であることを意味するデータ型
null: 値が存在しないことを意味するデータ型
シンボル（Symbol）: ES2015から追加された一意で不変な値のデータ型


リテラル
特徴：ミュータブル
具体例：
プリミティブ型以外のデータ
オブジェクト、配列、関数、クラス、正規表現、Dateなど


テンプレートリテラル内で${変数名}と書いた場合に、その変数の値を埋め込むことができる

```javascript
const str = "文字列";
console.log(`これは${str}です`); // => "これは文字列です"
```

## オブジェクトリテラル

オブジェクトリテラルは{}（中カッコ）を書くことで、新しいオブジェクトを作成できる
```javascript
const obj = {}; // 中身が空のオブジェクトを作成
```
```javascript
const obj = {
    "key": "value"
};
// ドット記法
console.log(obj.key); // => "value"
// ブラケット記法
console.log(obj["key"]); // => "value"
```

## 演算子

++インクリメント演算子、--ディクリメント演算子
```javascript
let num = 1;

num++; // num は 2 になる
++num; // num は 2 になる
```
違いは返り値

num++（後置インクリメント）
→ 先に今の値を返してから、num を +1 する

++num（前置インクリメント）
→ 先に num を +1 してから、増えた値を返す
```javascript
let num = 1;
console.log(num++); // 1（表示してから増える）
console.log(num);   // 2
```
```javascript
let num = 1;
console.log(++num); // 2（増やしてから表示）
console.log(num);   // 2
```
ディクリメント演算子も容量は同じ。

分割代入
```
const array = [1, 2];
// aには`array`の0番目の値、bには1番目の値が代入される
const [a, b] = array;
console.log(a); // => 1
console.log(b); // => 2
```

AND演算子（&&）
AND演算子（&&）は、左辺の値の評価結果がtrueならば、右辺の評価結果を返します。 一方で、左辺の値の評価結果がfalseならば、そのまま左辺の値を返します。
```javascript
// 左辺はfalsyではないため、評価結果として右辺を返す
console.log("文字列" && "右辺の値"); // => "右辺の値"
console.log(42 && "右辺の値"); // => "右辺の値"
// 左辺がfalsyであるため、評価結果として左辺を返す
console.log("" && "右辺の値"); // => ""
console.log(0 && "右辺の値"); // => 0
console.log(null && "右辺の値"); // => null
```

OR演算子（||）

OR演算子（||）は、左辺の値の評価結果がtrueならば、そのまま左辺の値を返し一方で、左辺の値の評価結果がfalseであるならば、右辺の評価結果を返す
```javascript
// 左辺がtrueなので、左辺の値が返される
console.log(true || "右辺の値"); // => true
// 左辺がfalseなので、右辺の値が返される
console.log(false || "右辺の値"); // => "右辺の値"
```

Nullish coalescing演算子(??)

Nullish coalescing演算子(??)は、左辺の値がnullishであるならば、右辺の評価結果を返します。 nullishとは、評価結果がnullまたはundefinedとなる値

```javascript
// 左辺がnullishであるため、右辺の値の評価結果を返す
console.log(null ?? "右辺の値"); // => "右辺の値"
console.log(undefined ?? "右辺の値"); // => "右辺の値"
// 左辺がnullishではないため、左辺の値の評価結果を返す
console.log(true ?? "右辺の値"); // => true
console.log(false ?? "右辺の値"); // => false
```

## 条件（三項）演算子（?と:）

条件式 ? Trueのとき処理する式 : Falseのとき処理する式;
```javascript
const valueA = true ? "A" : "B";
console.log(valueA); // => "A"
const valueB = false ? "A" : "B";
console.log(valueB); // => "B"
```

```javascript
function addPrefix(text, prefix) {
    // `prefix`が指定されていない場合は"デフォルト:"を付ける
    const pre = typeof prefix === "string" ? prefix : "デフォルト:";
    return pre + text;
}

console.log(addPrefix("文字列")); // => "デフォルト:文字列"
console.log(addPrefix("文字列", "カスタム:")); // => "カスタム:文字列"

```


グループ化演算子（(と)）
```javascript
const a = 1;
const b = 2;
const c = 3;
console.log(a + b * c); // => 7
console.log((a + b) * c); // => 9
```

```javascript
if ((typeof a === "string" && typeof b === "string") || (typeof x === "number" && typeof y === "number")) {
    // `a`と`b`が文字列型 または
    // `x`と`y`が数値型
}
```

Symbolとは「絶対に他と被らない“特別なID（値）”を作れるプリミティブ型」

```javascript
const a = Symbol("id");
const b = Symbol("id");

console.log(a === b); // false（説明が同じでも別物）
```

デフォルト引数

Nullish coalescing演算子(??)を利用することでも、 OR演算子（||）の問題を避けつつデフォルト値を指定できる

```javascript
function addPrefix(text, prefix) {
    const pre = prefix || "デフォルト:";
    return pre + text;
}
```

関数の仮引数に対して引数の個数が多い場合、あふれた引数は単純に無視されます。

可変長引数

関数において引数の数が固定ではなく、任意の個数の引数を受け取りたい場合
表記方法および具体例:Math.max(...args)は引数を何個でも受け取り、受け取った引数の中で最大の数値を返す関数
```javascript
const max = Math.max(1, 5, 10, 20);
console.log(max); // => 20
```

Rest parameters
```javascript
function fn(...args) {
    // argsは、渡された引数が入った配列
    console.log(args); // => ["a", "b", "c"]
}
fn("a", "b", "c");
```

```javascript
function fn(arg1, ...restArgs) {
    console.log(arg1); // => "a"
    console.log(restArgs); // => ["b", "c"]
}
fn("a", "b", "c");
```

2番目以降から代入する場合は、restArgsを使用する

Spread構文
配列を展開して関数の引数に渡す構文

Spread構文は、配列の前に...をつけた構文のことで、関数には配列の値を展開したものが引数として渡される

```javascript
function fn(x, y, z) {
    console.log(x); // => 1
    console.log(y); // => 2
    console.log(z); // => 3
}
const array = [1, 2, 3];
// Spread構文で配列を引数に展開して関数を呼び出す
fn(...array);
// 次のように書いたのと同じ意味
fn(array[0], array[1], array[2]);

```

 関数の引数と分割代入
 変数名.keyの形で取り出すことができる

```javascript
function printUserId(user) {
    console.log(user.id); // => 42
}
const user = {
    id: 42
};
printUserId(user);
```

オブジェクトの分割代入
```javascript
const user = {
    id: 42
};
// オブジェクトの分割代入
const { id } = user;
console.log(id); // => 42
// 関数の引数の分割代入
function printUserId({ id }) {
    console.log(id); // => 42
}
printUserId(user);
```

配列の分割代入
```javascript
function print([first, second]) {
    console.log(first); // => 1
    console.log(second); // => 2
}
const array = [1, 2];
print(array);
```

関数もオブジェクト
関数もオブジェクトなので引数に取ることができる

```javascript
function fn() {
    console.log("fnが呼び出されました");
}
// 関数`fn`を`myFunc`変数に代入している
const myFunc = fn;
myFunc();
```

関数式
関数式とは、関数を値として変数へ代入している式

```javascript
// 関数式
const 変数名 = function() {
    // 関数を呼び出したときの処理
    // ...
    return 関数の返り値;
};
```

```javascript
// 関数式は変数名で参照できるため、"関数名"を省略できる
const 変数名 = function() {
};
// 関数宣言では"関数名"は省略できない
function 関数名() {
}
```
関数式では、名前を持たない関数を変数に代入できる、このような名前を持たない関数を無名関数と言う

利用用途
関数式でも関数に名前をつけることができます。 しかし、この関数の名前は関数の外からは呼ぶことができません。 一方、関数の中からは呼ぶことができるため、再帰的に関数を呼び出す際などに利用されます。

```javascript
// factorialは関数の外から呼び出せる名前
// innerFactは関数の外から呼び出せない名前
const factorial = function innerFact(n) {
    if (n === 0) {
        return 1;
    }
    // innerFactを再帰的に呼び出している
    return n * innerFact(n - 1);
};
console.log(factorial(3)); // => 6
```

Arrow Function
関数式にはfunctionキーワードを使った方法以外に、Arrow Functionと呼ばれる書き方がある

```javascript
// Arrow Functionを使った関数定義
const 変数名 = () => {
    // 関数を呼び出したときの処理
    // ...
    return 関数の返す値;
};
```

```javascript
// 仮引数の数と定義
const fnA = () => { /* 仮引数がないとき */ };
const fnB = (x) => { /* 仮引数が1つのみのとき */ };
const fnC = x => { /* 仮引数が1つのみのときは()を省略可能 */ };
const fnD = (x, y) => { /* 仮引数が複数のとき */ };
// 値の返し方
// 次の２つの定義は同じ意味となる
const mulA = x => { return x * x; }; // ブロックの中でreturn
const mulB = x => x * x;            // 1行のみの場合はreturnとブロックを省略できる
```

```javascript
const array = [1, 2, 3];
// 仮引数が1つなので`()`を省略できる
// 関数の処理が1つの式なので`return`文を省略できる
const doubleArray = array.map(value => value * 2);
console.log(doubleArray); // => [2, 4, 6]
```

mapの処理：
配列の各要素を1つずつ取り出して関数を適用し、その結果を同じ順番で集めた“新しい配列”を返す

コールバック関数：引数として渡される関数のこと
```javascript
function 高階関数(コールバック関数) {
    コールバック関数();
}
```

```javascript
const array = [1, 2, 3];
const output = (value) => {
    console.log(value);
};
array.forEach(output);
// 次のように実行しているのと同じ
// output(1); => 1
// output(2); => 2
// output(3); => 3
```
forEachメソッドとは

配列の要素を先頭から1つずつ取り出して、指定した処理（関数）を実行するメソッド。
ただし 戻り値として新しい配列は返さない


コールバック関数となる無名関数をその場で定義して渡せます。

```javascript
const array = [1, 2, 3];
array.forEach((value) => {
    console.log(value);
});

```

メソッド

オブジェクトのプロパティである関数
```javascript
const obj = {
    method1: function() {
        // `function`キーワードでのメソッド
    },
    method2: () => {
        // Arrow Functionでのメソッド
    }
};
```

空オブジェクトのobjを定義してから、methodプロパティへ関数を代入してもメソッドを定義できる
```javascript
const obj = {};
obj.method = function() {
};
```

メソッドを呼び出す場合は、関数呼び出しと同様にオブジェクト.メソッド名()と書くことで呼び出せます。

```javascript
const obj = {
    method: function() {
        return "this is method";
    }
};
console.log(obj.method()); // => "this is method"
```

メソッドの短縮記法

オブジェクトリテラルの中で メソッド名(){ /*メソッドの処理*/ } と書くことができる

```javascript
const obj = {
    method() {
        return "this is method";
    }
};
console.log(obj.method()); // => "this is method"
```

文と式

42のようなリテラルやfooといった変数、関数呼び出しが式です。 また、1 + 1のような式と演算子の組み合わせも式


```javascript
// 1という式の評価値を表示
console.log(1); // => 1
// 1 + 1という式の評価値を表示
console.log(1 + 1); // => 2
// 式の評価値を変数に代入
const total = 1 + 1;
// 関数式の評価値(関数オブジェクト)を変数に代入
const fn = function() {
    return 1;
};
// fn() という式の評価値を表示
console.log(fn()); // => 1

```


処理する1ステップが1つの文

```javascript
const isTrue = true;
// isTrueという式がif文の中に出てくる
if (isTrue) {
}
```

## 式文
一方で、式（Expression）は文（Statement）になれます。文となった式のことを式文と呼びます。 基本的に文が書ける場所には式を書けます。

その際に、式文（Expression statement）は文の一種であるため、セミコロンで文を区切っています。

```javascript
// 式文であるためセミコロンをつけている
式;

ブロック文

{
    文;
    文;
}
```
基本的にはif文やfor文など他の構文と組み合わせて書く
```javascript
// if文とブロック文の組み合わせ
if (true) {
    console.log("文1");
    console.log("文2");
}
```
文の末尾にはセミコロンをつけるとしていましたが、 例外としてブロックで終わる文の末尾には、セミコロンが不要となっています。
```javascript
// ブロックで終わらない文なので、セミコロンが必要
if (true) console.log(true);
// ブロックで終わる文なので、セミコロンが不要
if (true) {
    console.log(true);
}
```

条件分岐

if文
if文を使うことで、プログラム内に条件分岐を書けます。

if文は次のような構文が基本形となります。 条件式の評価結果がtrueであるならば、実行する文が実行されます。
```javascript
if (条件式) {
    実行する文;
}
```

```javascript
if (true) {
    console.log("この行は実行されます");
}
```

実行する文が1つのみの場合は、{ と } のブロックを省略できるが、どこまでがif文かがわかりにくくなるため、常にブロックで囲むことが推奨されている

```javascript
if (true)
    console.log("この行は実行されます");
```

if文は条件式に比較演算子などを使い、その比較結果によって処理を分岐するためによく使われます。 次のコードでは、xが10よりも大きな値である場合に、if文の中身が実行されます。

```javascript
const x = 42;
if (x > 10) {
    console.log("xは10より大きな値です");
}
```

else if文
```javascript
const version = "ES6";
if (version === "ES5") {
    console.log("ECMAScript 5");
} else if (version === "ES6") {
    console.log("ECMAScript 2015");
} else if (version === "ES7") {
    console.log("ECMAScript 2016");
}
```
else文
```javascript
const num = 1;
if (num > 10) {
    console.log(`numは10より大きいです: ${num}`);
} else {
    console.log(`numは10以下です: ${num}`);
}
```

ネストしたif文
```javascript
if (条件式A) {
    if (条件式B) {
        // 条件式Aと条件式Bがtrueならば実行される文
    }
}
```

ネストしたif文の例として、今年がうるう年かを判定する

うるう年の条件
・西暦で示した年が4で割り切れる年はうるう年です
・ただし、西暦で示した年が100で割り切れる年はうるう年ではありません
・ただし、西暦で示した年が400で割り切れる年はうるう年です

```javascript
const year = new Date().getFullYear();
if (year % 4 === 0) { // 4で割り切れる
    if (year % 100 === 0) { // 100で割り切れる
        if (year % 400 === 0) { // 400で割り切れる
            console.log(`${year}年はうるう年です`);
        } else {
            console.log(`${year}年はうるう年ではありません`);
        }
    } else {
        console.log(`${year}年はうるう年です`);
    }
} else {
    console.log(`${year}年はうるう年ではありません`);
}
```

一般的にはネストは浅いほうが、読みやすいコードとなるので以下のように修正できる

```javascript
const year = new Date().getFullYear();
if (year % 400 === 0) { // 400で割り切れる
    console.log(`${year}年はうるう年です`);
} else if (year % 100 === 0) { // 100で割り切れる
    console.log(`${year}年はうるう年ではありません`);
} else if (year % 4 === 0) { // 4で割り切れる
    console.log(`${year}年はうるう年です`);
} else { // それ以外
    console.log(`${year}年はうるう年ではありません`);
}
```

## switch文

switch文は、次のような構文で式の評価結果が指定した値である場合に行う処理を並べて書く

```javascript
switch (式) {
    case ラベル1:
        // `式`の評価結果が`ラベル1`と一致する場合に実行する文
        break;
    case ラベル2:
        // `式`の評価結果が`ラベル2`と一致する場合に実行する文
        break;
    default:
        // どのcaseにも該当しない場合の処理
        break;
}
// break; 後はここから実行される
```

```javascript
const version = "ES6";
switch (version) {
    case "ES5":
        console.log("ECMAScript 5");
        break;
    case "ES6":
        console.log("ECMAScript 2015");
        break;
    case "ES7":
        console.log("ECMAScript 2016");
        break;
    default:
        console.log("しらないバージョンです");
        break;
}
// "ECMAScript 2015" と出力される

```



break;を忘れてしまうと意図しないcase節が実行されてしまいます。 そのため、case節とbreak文が多用されているswitch文が出てきた場合、 別の方法で書けないかを考えるべきサインとなります。

switch文はif文の代用として使うのではなく、次のように関数と組み合わせて条件に対する値を返すパターンとして使うことが多い

```javascript
function getECMAScriptName(version) {
    switch (version) {
        case "ES5":
            return "ECMAScript 5";
        case "ES6":
            return "ECMAScript 2015";
        case "ES7":
            return "ECMAScript 2016";
        default:
            return "しらないバージョンです";
    }
}
// 関数を実行して`return`された値を得る
getECMAScriptName("ES6"); // => "ECMAScript 2015"
```


ループと反復処理



while文

while文は条件式がtrueであるならば、反復処理を行う

```javascript
while (条件式) {
    実行する文;
}
```

```javascript
let x = 0;
console.log(`ループ開始前のxの値: ${x}`);
while (x < 10) {
    console.log(x);
    x += 1;
}
console.log(`ループ終了後のxの値: ${x}`);
```

無限ループ

```javascript
let i = 1;
// 条件式が常にtrueになるため、無限ループする
while (i > 0) {
    console.log(`${i}回目のループ`);
    i += 1;
}
```

do-while文
```javascript
do {
    実行する文;
} while (条件式);
```
do-while文の実行フロー

①実行する文を実行
②条件式 の評価結果がtrueなら次のステップへ、falseなら終了
③ステップ1へ戻る

必ず最初に実行する文を処理

そのため、次のコードのように最初から条件式を満たさない場合でも、 初回の実行する文が処理され、コンソールへ1000と出力されます。

```javascript
const x = 1000;
do {
    console.log(x); // => 1000
} while (x < 10);
```
for文

```javascript
for (初期化式; 条件式; 増分式) {
    実行する文;
}
```

for文の実行フローは次のようになります。

①初期化式 で変数の宣言
②条件式 の評価結果がtrueなら次のステップへ、falseなら終了
③実行する文 を実行
④増分式 で変数を更新
⑤ステップ2へ戻る

次のコードでは、for文で1から10までの値を合計して、その結果をコンソールへ出力

```javascript
let total = 0; // totalの初期値は0
// for文の実行フロー
// iを0で初期化
// iが10未満（条件式を満たす）ならfor文の処理を実行
// iに1を足し、再び条件式の判定へ
for (let i = 0; i < 10; i++) {
    total += i + 1; // 1から10の値をtotalに加算している
}
console.log(total); // => 55
```


任意の数値が入った配列を受け取り、その合計値を返す sum 関数を実装しています。 numbers配列に含まれている要素を先頭から順番に変数totalへ加算することで合計値を計算しています。

```javascript
function sum(numbers) {
    let total = 0;
    for (let i = 0; i < numbers.length; i++) {
        total += numbers[i];
    }
    return total;
}

console.log(sum([1, 2, 3, 4, 5])); // => 15
```

配列のforEachメソッド

forEachメソッドでの反復処理は、次のように書ける

```javascript
const array = [1, 2, 3];
array.forEach(currentValue => {
    // 配列の要素ごとに呼び出される処理
});
```

forEachメソッドのコールバック関数には、配列の要素が先頭から順番に渡されて実行される
```javascript
const array = [1, 2, 3];
array.forEach(currentValue => {
    console.log(currentValue);
});
// 1
// 2
// 3
// と順番に出力される
```
先ほどのfor文の例と同じ数値の合計を返すsum 関数をforEachメソッドで実装してみます。

```javascript
function sum(numbers) {
    let total = 0;
    numbers.forEach(num => {
        total += num;
    });
    return total;
}

sum([1, 2, 3, 4, 5]); // => 15
```

forEachはfor文の条件式に相当するものはなく、必ず配列のすべての要素を反復処理します。 変数iといった一時的な値を定義する必要がないため、シンプルに反復処理を書ける

## break文

break文は処理中の文から抜けて次の文へ移行する制御文

while (true) {
    break; // *1 へ
}
// *1 次の文
switch文で出てきたものと同様で、処理中のループ文を終了できます。

次のコードでは配列の要素に1つでも偶数を含んでいるかを判定しています。

```javascript
const numbers = [1, 5, 10, 15, 20];
// 偶数があるかどうか
let isEvenIncluded = false;
for (let i = 0; i < numbers.length; i++) {
    const num = numbers[i];
    // numが2で割り切れるなら偶数
    if (num % 2 === 0) {
        isEvenIncluded = true;
        break;
    }
}
console.log(isEvenIncluded); // => true
```

1つでも偶数があるかがわかればいいため、配列内から最初の偶数を見つけたらfor文での反復処理を終了します。 このような処理は、使い回せるように関数として実装する

```javascript
// 引数の`num`が偶数ならtrueを返す
function isEven(num) {
    return num % 2 === 0;
}
// 引数の`numbers`に偶数が含まれているならtrueを返す
function isEvenIncluded(numbers) {
    let isEvenIncluded = false;
    for (let i = 0; i < numbers.length; i++) {
        const num = numbers[i];
        if (isEven(num)) {
            isEvenIncluded = true;
            break;
        }
    }
    return isEvenIncluded;
}
const array = [1, 5, 10, 15, 20];
console.log(isEvenIncluded(array)); // => true
```

早期リターン：条件が見つかった状態ですぐに答えを返す
return文は現在の関数を終了させることができるため、次のように書くこともできます。 numbersに1つでも偶数が含まれていれば結果はtrueとなるため、偶数の値が見つかった時点でtrueを返しています。


```javascript
function isEven(num) {
    return num % 2 === 0;
}
function isEvenIncluded(numbers) {
    for (let i = 0; i < numbers.length; i++) {
        const num = numbers[i];
        if (isEven(num)) {
            return true;
        }
    }
    return false;
}
const numbers = [1, 5, 10, 15, 20];
console.log(isEvenIncluded(numbers)); // => true
```

## 配列のsomeメソッド

someメソッドは、配列の各要素をテストする処理をコールバック関数として受け取り、コールバック関数が、一度でもtrueを返した時点で反復処理を終了し、someメソッドはtrueを返す

```javascript
const array = [1, 2, 3, 4, 5];
const isPassed = array.some(currentValue => {
    // テストをパスするとtrue、そうでないならfalseを返す
});
```

someメソッドを使うことで、配列に偶数が含まれているかは次のように書くことができます。 受け取った値が偶数であるかをテストするコールバック関数としてisEven関数を渡し

```javascript
function isEven(num) {
    return num % 2 === 0;
}
const numbers = [1, 5, 10, 15, 20];
console.log(numbers.some(isEven)); // => true
```

## continue文

continue文は現在の反復処理を終了して、次の反復処理を行います。 continue文は、while、do-while、forの中で使うことができ

```javascript
while (条件式) {
    // 実行される処理
    continue; // `条件式` へ
    // これ以降の行は実行されません
}
```

```
// `number`が偶数ならtrueを返す
function isEven(num) {
    return num % 2 === 0;
}
// `numbers`に含まれている偶数だけを取り出す
function filterEven(numbers) {
    const results = [];
    for (let i = 0; i < numbers.length; i++) {
        const num = numbers[i];
        // 偶数ではないなら、次のループへ
        if (!isEven(num)) {
            continue;
        }
        // 偶数を`results`に追加
        results.push(num);
    }
    return results;
}
const array = [1, 5, 10, 15, 20];
console.log(filterEven(array)); // => [10, 20]

```

Falseの時は配列に入れずにTrueの時だけ配列に入れる
下記でもOK

```javascript
if (isEven(num)) {
    results.push(num);
}
```

## 配列のfilterメソッド

filterメソッドには、配列の各要素をテストする処理をコールバック関数として渡します。 コールバック関数がtrueを返した要素のみを集めた新しい配列を返す

```javascripta
const array = [1, 2, 3, 4, 5];
// テストをパスしたものを集めた配列
const filteredArray = array.filter((currentValue, index, array) => {
    // テストをパスするならtrue、そうでないならfalseを返す
});
```

filter は 「要素ごとに判定して、trueの要素だけ集める」。
currentValue が 判定対象の値 で、index(インデックス番号) と array(配列) は必要なときだけ使う

filterメソッドを使い、偶数だけの配列を作成する

```javascript
function isEven(num) {
    return num % 2 === 0;
}

const array = [1, 5, 10, 15, 20];
console.log(array.filter(isEven)); // => [10, 20]
```

## for...in文

for (プロパティ in オブジェクト) {
    実行する文;
}


const obj = {
    "a": 1,
    "b": 2,
    "c": 3
};
// 注記: ループのたびに毎回新しいブロックに変数keyが定義されるため、再定義エラーが発生しない
for (const key in obj) {
    const value = obj[key];
    console.log(`key:${key}, value:${value}`);
}
// "key:a, value:1"
// "key:b, value:2"
// "key:c, value:3"


オブジェクトに対する反復処理のためにfor...in文は有用に見えますが、多くの問題を持っています。

JavaScriptでは、オブジェクトは何らかのオブジェクトを継承しています。 for...in文は、対象となるオブジェクトのプロパティを列挙する場合に、親オブジェクトまで列挙可能なものがあるかを探索して列挙します。 そのため、オブジェクト自身が持っていないプロパティも列挙されてしまい、意図しない結果になる場合があります。

安全にオブジェクトのプロパティを列挙するには、Object.keys静的メソッド、Object.values静的メソッド、Object.entries静的メソッドなどが利用できます。

先ほどの例である、オブジェクトのキーと値を列挙するコードはfor...in文を使わずに書けます。 Object.keys静的メソッドは引数のオブジェクト自身が持つ列挙可能なプロパティ名の配列を返します。 そのためfor...in文とは違い、親オブジェクトのプロパティは列挙されません。

for...of文

for...of文では、iterableオブジェクトから次の返す値を1つ取り出し、variableに代入して反復処理を行う

```javascript
for (variable of iterable) {
    実行する文;
}
```

インデックス値ではなく配列の値を列挙します。

```javascript
const array = [1, 2, 3];
for (const value of array) {
    console.log(value);
}
// 1
// 2
// 3
```
JavaScriptではStringオブジェクトもiterableです。 そのため、文字列を1文字ずつ列挙できます。

```javascript
const str = "𠮷野家";
for (const value of str) {
    console.log(value);
}
// "𠮷"
// "野"
// "家"
```


## 次やること
- 
- 


## 感じたこと
- 

## 学習時間
- 
