## 取り組んだ課題一覧  
- Docker
  - Railsの環境構築
    - 復習
    - Qiita記事
    - README作成

## わかったこと
### docker compose の基本コマンド比較：up / build / run

#### 1. `docker compose up`
- `docker-compose.yml` に定義されたサービス（web, db など）を**起動**する。
- すでにビルド済みのイメージがあればそれを使う。
- なければ自動でビルドも行う。
- アプリを起動して継続的に動かしたいときに使う。

```bash
docker compose up
```

##### 特徴：
- コンテナを「起動しっぱなし」にする（Ctrl+Cで停止）
- 複数サービス（例：Rails＋DB）を同時に立ち上げる
- 必要に応じて `--build` を追加することで、ビルドも強制できる

---

#### 2. `docker compose build`
- `Dockerfile` を元に、**イメージを作成するだけ**のコマンド。
- コンテナは起動しない。
- コードや依存関係が変わったあとに、「起動せずビルドだけしたい」ときに使う。

```bash
docker compose build
```

##### 特徴：
- ビルド結果（イメージ）はローカルに保存される
- 起動 (`up`) や実行 (`run`) の前に準備するための処理

---

#### 3. `docker compose run`
- 一時的に指定したサービスのコンテナを立ち上げ、**コマンド1つだけ実行**してすぐ終了する。
- `up` のように継続的に動かさず、「単発の作業」（例：DB作成など）に使う。

```bash
docker compose run web rails db:create
```

##### 特徴：
- 実行後、コンテナは基本的に自動で削除される（--rm 相当）
- `depends_on` の設定が効かない（必要なサービスは自分で先に立ち上げる必要あり）
- 一時的な処理（`db:create`, `rake task`, `rails console` など）に最適

---

### docker compose build / up / run の使い分け例

- **Dockerfile や Gemfile を変更した後に、イメージだけを再構築したいとき**  
  → `docker compose build` を使う  
  → コンテナは起動せず、イメージだけを最新化したい場面に最適

- **アプリ（Rails + DBなど）を起動して、ローカルでアクセス・開発したいとき**  
  → `docker compose up` を使う  
  → サービスがすべて立ち上がり、RailsサーバーやPostgreSQLが常時起動状態になる

- **初期設定など、コンテナ内で1回だけコマンドを実行したいとき（例：rails db:create）**  
  → `docker compose run web rails db:create` のように使う  
  → 一時的なコンテナを使い、コマンド実行後に自動で停止・削除される。Railsのタスクやバッチ処理向き

---

### docker compose up --build とは？

Dockerfile や Gemfile などを変更したあとに、  
**最新の状態で再ビルドしてからコンテナを起動するコマンド**。

```bash
docker compose up --build
```

#### 主な用途：
- イメージを**強制的に再構築**したいとき
- 修正内容を確実に反映して**コンテナを起動したい**とき

#### よくある使用タイミング：
- `Dockerfile` を変更したあと
- `Gemfile` や `yarn.lock` を更新したあと
- ライブラリの追加・バージョン変更をしたあと

## 次やること
- Docker
  - Railsの環境構築
    - Qiita記事完成
    - 課題URL提出
- Python
  - Udemy 

## 感じたこと
- 完璧主義になりQiitaの記事作成に時間がかかってしまっている。8割で完了。→残り時間で100%に近づけるというふうにしていく。
- 集中して学習ができている。起きてからの3時間はとにかく新しいこと理解しづらいことに時間を使う。疲れてきたら復習などの頭をあまり使わないことに切り替える。

## 学習時間
- 8.10h
