## 取り組んだ課題一覧  
- Python_Udemy
  - 復習
    - 関数_s45〜59
    - モジュール_s60〜69
    - オブジェクト指向_s70~74

## わかったこと

### ■ return と print の違いまとめ

#### 【return】
- 関数の結果（値）を呼び出し元に返す  
- 数値・文字列・リストなど何でも返せる  
- 呼び出し元で変数に代入したり、他の計算に利用できる  
- 例：お持ち帰り（テイクアウト）

```python
def add(a, b):
    return a + b

x = add(3, 5)   # 8 が返ってくる
print(x * 2)    # 16
```

---

#### 【print】
- 値を画面に表示するだけ  
- 呼び出し元には値を返さない  
- 戻り値は必ず None になる（＝「空っぽ」という意味）  
- その場で確認したい時に便利  
- 例：店内で食べる（その場だけ）

```python
def add(a, b):
    print(a + b)

y = add(3, 5)   # 8 と表示されるが y には None が入る
print(y)        # None と表示される
```

---

### ■ 使い分け
- 結果をあとで使いたい → return  
- その場で見れればOK → print  
- print を使った関数の戻り値は必ず None になることを忘れない  

---

### ■ .get の使い方まとめ

【基本】  
- 辞書（dict）専用のメソッド  
- 辞書から指定したキーの値を取り出す  
- キーが存在しなければ None を返す  
- 第2引数を指定すると、その値をデフォルト値として返す  

【構文】
```python
dict.get(key, default)
```

【例】
```python
data = {"name": "太久磨", "age": 28}

print(data.get("name"))             # "太久磨"
print(data.get("height"))           # None
print(data.get("height", "未設定")) # "未設定"
```

---

### ■ Python のオブジェクトの変更可否まとめ

【変更できるオブジェクト（mutable）】  
- list（リスト）  
- dict（辞書）  
- set（集合）  
- bytearray  
- ユーザー定義クラスのインスタンス（多くの場合）  

```python
lst = [1, 2, 3]
lst[0] = 100
print(lst)  # [100, 2, 3]
```

【変更できないオブジェクト（immutable）】  
- int（整数）  
- float（浮動小数点数）  
- complex（複素数）  
- str（文字列）  
- tuple（タプル）  
- frozenset（変更不可の集合）  
- bytes（バイト列）  

```python
s = "hello"
# s[0] = "H"  # エラー！ str は変更不可
s = "Hello"   # 新しい文字列オブジェクトを作り直しているだけ
```

【ポイント】  
- mutable：中身を直接書き換えられる  
- immutable：中身を書き換え不可。再代入すると新しいオブジェクトが作られる  

---

### ■ for / *args / in の使い方まとめ

【*args】  
- 関数に渡された「個数が決まっていない引数」をタプルで受け取る  

```python
def func(*args):
    print(args)

func(1, 2, 3)   # (1, 2, 3)
```

【for】  
- 繰り返し処理  
- 1つずつ要素を取り出して変数に入れる  

```python
for x in [1, 2, 3]:
    print(x)
# 1, 2, 3 と順番に出力
```

【in】  
- 要素の存在確認やループで使用  

```python
fruits = ["りんご", "みかん"]
print("りんご" in fruits)   # True
print("バナナ" in fruits)   # False
```

【今回の応用例】
```python
def add_or_remove(fruits, *args):
    for fruit in args:
        if fruit in fruits:
            fruits.remove(fruit)  # すでにあるなら削除
        else:
            fruits.append(fruit)  # なければ追加
    return fruits
```

---

### ■ Python の変数参照ルール（LEGB）

【探索順序】  
1. Local（ローカル）  
2. Enclosing（外側ローカル）  
3. Global（グローバル）  
4. Built-in（組み込み）  

【ポイント】  
- 関数内は「ローカル → 外側 → グローバル → 組み込み」の順で探す  
- ローカル変数は関数の外から参照できない  
- グローバル変数は関数の中から参照できる  

---

### ■ 関数を返す仕組みまとめ

【ポイント】  
- 関数名 → 関数そのもの（オブジェクト）  
- 関数名() → 関数を実行した結果  

```python
def return_func():
    def inner_func():
        print("This is an inner function")
    return inner_func

f = return_func()
print(type(f))  # <class 'function'>
f()
```

【もし return inner_func() にしたら】  
- inner_func を実行した結果が返る  
- f には関数ではなく「実行結果の値」が入る  

---

### ■ 関数の使い方を調べる方法

【1】docstring を見る
```python
print(len.__doc__)
# Return the number of items in a container.
```

【2】help() を使う
```python
help(len)
# Help on built-in function len:
# len(obj, /)
#     Return the number of items in a container.
```

【補足】  
- __doc__ → シンプルに説明だけ  
- help()  → 詳細なヘルプ  

---

### ■ 正規表現の繰り返し記号まとめ（* と +）

【*】アスタリスク → 「0回以上」  
```python
import re
print(bool(re.match(r"a*b", "b")))       # True
print(bool(re.match(r"a*b", "ab")))      # True
print(bool(re.match(r"a*b", "aaaaab")))  # True
```

【+】プラス → 「1回以上」  
```python
print(bool(re.match(r"a+b", "ab")))      # True
print(bool(re.match(r"a+b", "aaaaab")))  # True
print(bool(re.match(r"a+b", "b")))       # False
```

---

### ■ __name__ と __main__ の仕組み

【ルール】  
- スクリプトを直接実行したとき → __name__ = "__main__"  
- 他のスクリプトから import されたとき → __name__ = "モジュール名"  

```python
# sample.py
print(__name__)
```

実行例:  
```bash
python sample.py     # "__main__"
```

```python
import sample        # "sample"
```

## 次やること
- Python_Udemy
  - 復習
    - 関数_s75~87
    
## 感じたこと
- 勉強の隙間にスマホを触らなかったら集中して学習できた。
- わからないことは必ず理解しながら前に進むことが重要。

## 学習時間
- 6.20h
