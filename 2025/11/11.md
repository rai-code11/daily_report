## 取り組んだ課題一覧
- ECサイト_カート機能

## わかったこと
### Djangoの request オブジェクトと request.POST.get() の仕組み

#### ■ requestとは
Djangoがクライアント（ブラウザなど）から受け取った情報をまとめたオブジェクト。  
「ユーザーのリクエスト内容」がすべて入っている。

##### 主な属性
- request.method … リクエストの種類（"GET" / "POST" など）
- request.GET … URLクエリのデータ（例: /product?id=3 の id=3）
- request.POST … フォーム送信（POST）のデータ
- request.session … セッション情報（ユーザーごとの一時データ）
- request.user … ログイン中のユーザー情報
- request.FILES … ファイルアップロードのデータ

---

#### ■ request.POST.get("quantity", 1) の意味
POSTデータの中からキー "quantity" の値を取得する。  
もし存在しなければデフォルト値 1 を返す。

サンプル:
```python
quantity = request.POST.get("quantity", 1)
```

動き:
1) request.POST は、HTMLフォームから送られたデータを保持する「辞書のような」オブジェクト  
   例: {"product_id": "3", "quantity": "2"}  
2) .get("quantity", 1) は "quantity" キーの値を取り出す。なければ 1 を返す。

---

#### ■ 実際のフォーム例と対応
HTML 側:
```html
 <form method="POST">
   <input type="number" name="quantity" value="3">
   <button type="submit">カートに追加</button>
 </form>
```

サーバ側で見える想定（擬似表現）:
```python
request.POST = {"quantity": "3"}
```

取得例:
```python
request.POST.get("quantity", 1)  # => "3"
```

もし name="quantity" が無ければ:
```python
request.POST.get("quantity", 1)  # => 1（デフォルト）
```

---

#### まとめ
- request はユーザーから届いた情報の集合体
- request.POST はフォーム送信（POST）のデータ
- .get("key", デフォルト値) で安全に取り出せる
- HTML の name 属性がキー名になる

---

#### 追加ポイント（GETパラメータ）
URLのクエリ（/products?page=2 など）を取得するには:
```python
page = request.GET.get("page", 1)
```

---

### Djangoのメッセージフレームワーク

#### ■ メッセージの種類
Django には5種類のメッセージレベルがある。  
ビューでこれらを使うことで、ユーザーに一時的な通知を表示できる。

| 関数 | 意味 | 用途の例 |
|------|------|-----------|
| messages.debug() | デバッグ用 | 開発時の内部メッセージ |
| messages.info() | 情報 | 一般的な案内（例: 保存しました） |
| messages.success() | 成功 | 成功時の通知（例: 商品を追加しました） |
| messages.warning() | 警告 | 注意喚起（例: 在庫が少ないです） |
| messages.error() | エラー | 入力ミスや処理失敗（例: 数量が不正です） |

---

#### ■ テンプレート側の表示例
```html
 {% if messages %}
   <ul class="messages">
     {% for message in messages %}
       <li class="{{ message.tags }}">{{ message }}</li>
     {% endfor %}
   </ul>
 {% endif %}
```

---

### Djangoの `redirect()` の使い方と動き

#### ■ 概要
- `redirect()` は 別のURLへ転送するHTTPレスポンス（リダイレクト） を返すヘルパー。
- 返り値は `HttpResponseRedirect`（通常は 302）や `HttpResponsePermanentRedirect`（301）相当。
- POST→リダイレクト→GET（PRGパターン） によく使う。メッセージフレームワークとも相性が良い。

---

#### ■ 基本形（3通り）
```python
from django.shortcuts import redirect

# 1) URL文字列へ
return redirect("/checkout/")

# 2) URLパターン名へ（推奨：URLconfに依存し、安全・堅牢）
return redirect("checkout:checkout")

# 3) URLパターン名＋引数
return redirect("product:detail", product_id=42)   # kwargs
# または
return redirect("product:detail", 42)              # args
```

---

### get_or_create() と session_key の動きまとめ

#### 例
```python
session_key = _ensure_cart_session(request)
cart_obj, created = Cart.objects.get_or_create(session_id=session_key)
```

#### 解説
- `session_key = _ensure_cart_session(request)`  
  この時点でブラウザ固有のセッションID（`session_key`）を取得。  
  Djangoが自動でCookieとDB（`django_session`）に保存してくれるので、こちらは値を使うだけでOK。

- `Cart.objects.get_or_create(session_id=session_key)`  
  `Cart`テーブルを 検索→なければ新規作成して保存。  
  既存が見つかった場合：既存行を返すだけ（保存はしない）→ `created = False`  
  見つからない場合：新規作成して保存 → `created = True`

#### 要点
- 「毎回保存」ではなく、存在しないときだけ保存。  
- これにより、1ブラウザ（=1セッション）につき1つの`Cart`を自動的に一意にできる。

---

### Django ORM：filter() の使い方まとめ

#### filter() の基本構文
filter() の引数には「モデルのフィールド名」と「条件」を指定します。
```python
Model.objects.filter(フィールド名=値)
```

---

#### 基本形
たとえば、`Product` モデルが次のように定義されているとします。
```python
class Product(models.Model):
    name = models.CharField(max_length=100)
    price = models.IntegerField()
    category = models.CharField(max_length=50)
```

このモデルに対して次のように書くと：
```python
Product.objects.filter(price=1000)
```
→ `price` フィールドが 1000円のものだけ を取得します。

---

#### よく使う条件指定（ルックアップ句）
Djangoではフィールド名の後ろに「`__`（アンダースコア2つ）」を付けて条件を細かく指定できます。  
これを lookup句（ルックアップ） と呼びます。

| ルックアップ | 意味 | 使用例 |
|---------------|------|--------|
| exact | 一致（デフォルトなので省略可） | `price__exact=1000`（＝`price=1000`） |
| gt | より大きい（greater than） | `price__gt=1000` |
| gte | 以上（greater than or equal） | `price__gte=1000` |
| lt | より小さい（less than） | `price__lt=1000` |
| lte | 以下（less than or equal） | `price__lte=1000` |
| contains | 部分一致（大文字小文字区別あり） | `name__contains="Tシャツ"` |
| icontains | 部分一致（大文字小文字区別なし） | `name__icontains="tシャツ"` |
| in | 複数の値の中に含まれる | `category__in=["服", "雑貨"]` |
| isnull | NULLかどうか | `category__isnull=True` |
| startswith | 前方一致 | `name__startswith="夏"` |
| endswith | 後方一致 | `name__endswith="限定"` |

---

#### 複数条件を指定する

##### AND条件（両方一致するもの）
```python
Product.objects.filter(category="服", price__gte=3000)
```
→ 「カテゴリーが服」かつ「価格が3000円以上」の商品を取得。

##### OR条件（どちらか一致するもの）
OR条件を使いたい場合は Qオブジェクト を使用します。
```python
from django.db.models import Q
Product.objects.filter(Q(category="服") | Q(price__gte=3000))
```
→ 「カテゴリーが服」または「価格が3000円以上」の商品を取得。

---

### メモ：Django の `F()` ってなに？

#### 一言定義
通常は「get → Pythonで計算 → save」だけど、F()ならDB内で直に quantity = quantity + X を実行できる＝1発SQL・原子的・高速

---

#### 例で直感！
悪い例（取り出してから足す：競合に弱い・往復が多い）
```python
item = CartItem.objects.get(id=1)
item.quantity += 1
item.save()
```

良い例（DBに直接「quantity = quantity + 1」と命令：強い＆速い）
```python
from django.db.models import F
CartItem.objects.filter(id=1).update(quantity=F("quantity") + 1)
```

ポイント：上は 単一SQL で更新。レースコンディションに強く、高速。

---

#### できること（よく使うやつ）
加算・減算（在庫／カートの定番）
```python
CartItem.objects.filter(id=1).update(quantity=F("quantity") + 3)
CartItem.objects.filter(id=1).update(quantity=F("quantity") - 1)
```

フィールド同士の比較（割引が通常価格より小さい）
```python
Product.objects.filter(price__gt=F("discount_price"))
```

フィールド同士で計算して更新（合計 = 単価 × 数量）
```python
OrderLine.objects.update(total=F("price") * F("quantity"))
```

---

#### なんで嬉しいの？
- 安全：`quantity = quantity + 1` が 原子的 に実行され、同時更新に強い。  
- 速い：読み出し→書き戻しの 往復なし。計算はDB側で完結。  
- 表現力： 列どうし の足し算・比較・乗算などを そのまま記述 できる。

---

### `HTTP_REFERER` と リダイレクト先の整理メモ

#### 1. `HTTP_REFERER` の役割（＝直前に見ていたページ）
- `request.META.get("HTTP_REFERER", "home")` の第1引数 `"HTTP_REFERER"` は、今のページではなく「直前のページのURL」を返す。  
- 例：  
  直前のページ：`/products/101/`（商品詳細）  
  実行ビュー：`AddToCartView`（カート追加処理）  
  リダイレクト先：`/products/101/`（= `HTTP_REFERER`）
```python
# 直前ページに戻す（参照元があればそこへ）
return redirect(request.META.get("HTTP_REFERER", "home"))
```
これで「元の画面に戻る」という目的は達成できる。

#### 2. `"home"` の役割（＝デフォルトの避難先）
- 第2引数 `"home"` は、`HTTP_REFERER` が無い場合に使うデフォルト。  
- 通常は URLパターン名（`urls.py` の `name='home'`）として解決される。

#### 3. デフォルト値に「URLパターン名」も「URLパス」も指定可能
| 目的 | 記述方法 | 意味 |
|---|---|---|
| URLパターン名で指定 | `return redirect("home")` | `urls.py` の `name='home'` にリダイレクト |
| URLパスを直接指定 | `return redirect("/")` | ルート（トップページ）へリダイレクト |

> `redirect()` はURLパターン名でも実際のURL文字列でも受け付ける。

#### 4. 実装テンプレート
```python
# 直前ページが取得できればそこへ、無ければ home へ
return redirect(request.META.get("HTTP_REFERER", "home"))
```
```python
# デフォルトをパスで指定したい場合（例：トップへ）
return redirect(request.META.get("HTTP_REFERER", "/"))
```

---

### `get_object_or_404` を使った「カート特定 → アイテム特定」の意味まとめ

#### 目的
「このセッションのカートに属する、そのアイテムだけ」を安全に特定して削除・更新するための二段階チェック。

#### 1. セッションのカートを一意に特定する
```python
cart = get_object_or_404(Cart, session_id=session_key)
```
- やっていること：`session_id == session_key` の `Cart` を 1件だけ取得  
- 見つからなければ：`Http404`（= 404ページ）で即終了  
- 狙い：まず「今このユーザーのカート」を 確実に特定 してから次へ進む  
- 補足：`Cart.session_id` は `unique=True` にしておくと安全（複数一致の事故を防ぐ）

#### 2. そのカートに結びついた、該当アイテムだけを特定する
```python
item = get_object_or_404(CartItem, id=cart_item_id, cart=cart)
```
- やっていること：`id == cart_item_id` かつ `cart == 上で特定したcart` の `CartItem` を取得  
- 見つからなければ：`Http404`  
- 狙い：URL改ざんなどで他人の `cart_item_id` を指定されても、自分のカートに存在しない限りヒットしない（= 所有チェック）

#### なぜこの2ステップが大事？
- 所有の担保：`id=cart_item_id` だけだと他人のアイテムに触れる危険。`cart=cart` を組み合わせて 自分のカート範囲に限定。  
- 失敗時の明確さ：存在しなければ 404 を返して 不正や不整合を即座に検知。  
- 読みやすい意図：①カート特定 → ②アイテム特定 の順で、意図がコードに現れる。

---

### `get_context_data()` は何者？（Django 汎用クラスベースビューで使うメソッド）

#### 結論
- はい、その認識でOK。  
  `get_context_data()` は 汎用クラスベースビュー（CBV）（`TemplateView` / `ListView` / `DetailView` など）で テンプレートに渡すコンテキストを組み立て・拡張するために使うメソッド。

#### 役割
- 親クラスが用意したデフォルトの `context`（例：`object_list` や `object` など）に、任意の値を追加できる。  
- 使うときは `super().get_context_data(**kwargs)` を必ず呼ぶのが鉄則。これを忘れると親が用意した値が消える。  
CBVを使っているときにテンプレートへ渡すデータを増やす場所が get_context_data()。  
親を呼んでから値を足す → return context の流れを守ればOK。

---


## 次やること
- 
- 


## 感じたこと
- 

## 学習時間
- 4.1h
