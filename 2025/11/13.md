## 取り組んだ課題一覧
- Django_ECサイト
 - 一覧ページのAdd to cartのテンプレート編集
 - 詳細ページのAdd to cartのテンプレート編集
 - 一覧ページのカート合計

## わかったこと

### ■ カート追加の全体の流れ

1. HTMLのフォームから送信される内容
   - method: `POST`
   - `quantity=1`（フォームの input など）
   - `product_id`（URL の一部：例 `add/3/` の `3`）

2. `AddToCartView.post(self, request, product_id)` が呼ばれる

3. 個数の取得  
   `quantity = request.POST.get("quantity", 1)`  
   - フォームから `"quantity"` を取得  
   - なければデフォルトで `1`

4. セッションIDを元に Cart を `get_or_create`
   - セッションID（`session_key`）を使って Cart を取得
   - なければ新規作成

5. `CartItem` を `get_or_create` する
   - 新規作成の場合：`quantity` の値で作成
   - 既存の場合：`F("quantity") + quantity` で加算更新

6. メッセージを出して、元のページに `redirect`  
   - 例：一覧ページ / 詳細ページ など、元の画面に戻す

---

### ■ get_or_create がやってくれていること

使用例：
```python
    cart_item, item_created = CartItem.objects.get_or_create(
        cart=cart_obj,
        product_id=product_id,
        defaults={"quantity": quantity}
    )
```
`get_or_create()` のざっくりした動き：

1. まず Django 内部でこういうイメージの検索をする：
```python
       CartItem.objects.get(cart=cart_obj, product_id=product_id)
```
2. もし「見つかった」場合
   - その既存の `CartItem` を `cart_item` として返す
   - `item_created = False`

3. もし「見つからなかった」場合
   - 新しく `CartItem(cart=cart_obj, product_id=product_id, quantity=quantity)` を作る
   - それを `cart_item` として返す
   - `item_created = True`

`defaults={"quantity": quantity}` の意味：

- 新規作成する場合にだけ、  
  `quantity` フィールドに `quantity` の値を入れてね、という指定。

---

### ■ コンテキストプロセッサが `context["xxx"]` を使わない理由（要点まとめ）

#### ● 1. ビューとコンテキストプロセッサの役割の違い

##### 【ビュー】

ビューは「すでに存在している `context` 辞書を編集する場所」。
```python
    def get_context_data(self, **kwargs):
        context = super().get_context_data(**kwargs)
        context["total_price"] = 500
        return context
```
- ここでは `context` が最初から存在していて、
- それにキーを足していくイメージ。

→ ビューは **context を操作する役割**。

---

##### 【コンテキストプロセッサ】

コンテキストプロセッサは「新しく辞書を作って return するだけ」の関数。
```python
    def cart_context_processor(request):
        return {"cart_total_quantity": 3}
```
- `context` という変数はここには登場しない
- 「テンプレに追加したい値を辞書で返すだけ」

→ コンテキストプロセッサは **context を編集しない。値を返すだけ**。

---

#### ● 2. なぜ `context["xxx"] = ...` と書かないのか？

理由はシンプル。

> コンテキストプロセッサ内には  
> **「context」という変数自体が存在しない** から。

- ビュー：`context` が渡される／作られるので、それを編集する
- コンテキストプロセッサ：`request` しか渡されない。  
  だから「返す値」を自分で辞書として組み立てて `return` する

---

#### ● 3. Django がやっている流れ（イメージ）

内部的な流れはだいたいこんな感じ：

1. View が `context` を作る  
   例：
```python
       context = {"title": "Detail", "product": product_obj}
```
2. 設定されているすべての `context_processor` を呼び出す
```python
       cp1 → {"cart_total_quantity": 5}
       cp2 → {"site_name": "MyShop"}
```
3. View の `context` と、各 context_processor が返した辞書をマージする

       最終的な context:
```python
       {
           "title": "Detail",
           "product": product_obj,
           "cart_total_quantity": 5,
           "site_name": "MyShop",
       }
```
5. その最終 `context` がテンプレートに渡される

→ だからコンテキストプロセッサ内では  
**「return {キー: 値}」と書くだけでテンプレから使えるようになる。**

---

#### 4. 最終まとめ

- ビュー → `context` 辞書を **編集する場所**
- context_processor → **辞書を返すだけの関数**
- Django 側で、view の context と processor の return dict を合体させてテンプレへ渡す
- だから context_processor 内では `context["xxx"] = ...` と書かない／書けない

---


## 次やること
- 一覧ページのカート合計
- 決済ページの削除ボタンを作成
- 決済ページのカート合計、小計、商品の表示


## 感じたこと
- Djangoのコンテキストプロセッサー便利すぎた。普通viewsで渡したcontextの値はそのビューでレンダリングするテンプレートでしか使えないけど、コンテキストプロセッサーにしておけば、共通の値をどのテンプレートからでも使える。グローバルな共通変数をいい感じに管理できる仕組みって感じがする
- Djangoこれやってるだけでは？！動的に表示させたい全ての処理は関数で返される。フロントからの値を引数requestなどから取得して、それを元に処理を記述。値をviewクラスならcontextに入れて、関数なら辞書で返して、テンプレに埋め込めば良い.そこにDB操作などなど絡んで来ると複雑になるのだけど
- 
## 学習時間
- 5.25h
