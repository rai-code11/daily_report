## 取り組んだ課題一覧
- Django_ECサイト
 - 一覧ページのAdd to cartのテンプレート編集
 - 詳細ページのAdd to cartのテンプレート編集
 - 一覧ページのカート合計

## わかったこと

### ■ カート追加の全体の流れ

1. HTMLのフォームから送信される内容
   - method: `POST`
   - `quantity=1`（フォームの input など）
   - `product_id`（URL の一部：例 `add/3/` の `3`）

2. `AddToCartView.post(self, request, product_id)` が呼ばれる

3. 個数の取得  
   `quantity = request.POST.get("quantity", 1)`  
   - フォームから `"quantity"` を取得  
   - なければデフォルトで `1`

4. セッションIDを元に Cart を `get_or_create`
   - セッションID（`session_key`）を使って Cart を取得
   - なければ新規作成

5. `CartItem` を `get_or_create` する
   - 新規作成の場合：`quantity` の値で作成
   - 既存の場合：`F("quantity") + quantity` で加算更新

6. メッセージを出して、元のページに `redirect`  
   - 例：一覧ページ / 詳細ページ など、元の画面に戻す

---

### ■ get_or_create がやってくれていること

使用例：
```python
    cart_item, item_created = CartItem.objects.get_or_create(
        cart=cart_obj,
        product_id=product_id,
        defaults={"quantity": quantity}
    )
```
`get_or_create()` のざっくりした動き：

1. まず Django 内部でこういうイメージの検索をする：
```python
       CartItem.objects.get(cart=cart_obj, product_id=product_id)
```
2. もし「見つかった」場合
   - その既存の `CartItem` を `cart_item` として返す
   - `item_created = False`

3. もし「見つからなかった」場合
   - 新しく `CartItem(cart=cart_obj, product_id=product_id, quantity=quantity)` を作る
   - それを `cart_item` として返す
   - `item_created = True`

`defaults={"quantity": quantity}` の意味：

- 新規作成する場合にだけ、  
  `quantity` フィールドに `quantity` の値を入れてね、という指定。

---

### ■ コンテキストプロセッサが `context["xxx"]` を使わない理由（要点まとめ）

#### ● 1. ビューとコンテキストプロセッサの役割の違い

##### 【ビュー】

ビューは「すでに存在している `context` 辞書を編集する場所」。
```python
    def get_context_data(self, **kwargs):
        context = super().get_context_data(**kwargs)
        context["total_price"] = 500
        return context
```
- ここでは `context` が最初から存在していて、
- それにキーを足していくイメージ。

→ ビューは **context を操作する役割**。

---

##### 【コンテキストプロセッサ】

コンテキストプロセッサは「新しく辞書を作って return するだけ」の関数。
```python
    def cart_context_processor(request):
        return {"cart_total_quantity": 3}
```
- `context` という変数はここには登場しない
- 「テンプレに追加したい値を辞書で返すだけ」

→ コンテキストプロセッサは **context を編集しない。値を返すだけ**。

---

#### ● 2. なぜ `context["xxx"] = ...` と書かないのか？

理由はシンプル。

> コンテキストプロセッサ内には  
> **「context」という変数自体が存在しない** から。

- ビュー：`context` が渡される／作られるので、それを編集する
- コンテキストプロセッサ：`request` しか渡されない。  
  だから「返す値」を自分で辞書として組み立てて `return` する

---

#### ● 3. Django がやっている流れ（イメージ）

内部的な流れはだいたいこんな感じ：

1. View が `context` を作る  
   例：
```python
       context = {"title": "Detail", "product": product_obj}
```
2. 設定されているすべての `context_processor` を呼び出す
```python
       cp1 → {"cart_total_quantity": 5}
       cp2 → {"site_name": "MyShop"}
```
3. View の `context` と、各 context_processor が返した辞書をマージする

       最終的な context:
```python
       {
           "title": "Detail",
           "product": product_obj,
           "cart_total_quantity": 5,
           "site_name": "MyShop",
       }
```
5. その最終 `context` がテンプレートに渡される

→ だからコンテキストプロセッサ内では  
**「return {キー: 値}」と書くだけでテンプレから使えるようになる。**

---

#### 4. 最終まとめ

- ビュー → `context` 辞書を **編集する場所**
- context_processor → **辞書を返すだけの関数**
- Django 側で、view の context と processor の return dict を合体させてテンプレへ渡す
- だから context_processor 内では `context["xxx"] = ...` と書かない／書けない

---

### View と Context Processor の仕組みの違い（メモ）

---

#### ①View は “テンプレートとセットの特別な存在”

View には Django が用意してくれている **テンプレート連携の仕組み** がある。

- `context = {...}` を作る
- `return render()` や `get_context_data()` で `context` を返す／渡す
- Django が自動でその `context` をテンプレートへ渡す

そのため View の中では：
```python
    context["xxx"] = 値
```
のように書くだけで、  
テンプレートから `{{ xxx }}` として使える。

---

#### ②通常の関数（context_processor 以外）は「ただの Python 関数」

普通の関数には次のような仕組みは **一切ない**。

- テンプレ連携
- context をテンプレに混ぜ込む処理
- Django が自動で拾ってくれる処理

そのため、テンプレに渡したい値がある場合は：

- view から `render()` に渡す
- context_processor として登録する

などの「ルート」に乗せる必要がある。

---

#### ③context_processor は「追加辞書を返す専門職」

context_processor の役割は一言でいうと：

> **テンプレートに追加したい値を辞書で返すだけの関数**

ビューのように最初から `context` 辞書があるわけではないので、  
`context` を編集するのではなく、**新しい辞書を返すだけ**。

Django は

- view が作った context  
- 各 context_processor が返した辞書  

をまとめて、最終的な context としてテンプレに渡す。

イメージ：

- view の context  
```html
      {"title": "Detail", "product": obj}
```
- processor の return  
```html
      {"cart_total_quantity": 5}
```
- 最終的な context  
```html
      {"title": "Detail", "product": obj, "cart_total_quantity": 5}
```
---

### @property の意味（超簡潔まとめ）

#### @property とは？

メソッドを **「属性（フィールド）みたいに」呼び出せるようにする仕組み**。

本来なら：
```python
    icon.icon_thumb_url()
```
のように「メソッド呼び出し（カッコ付き）」をするところを、

@property を付けると：
```python
    icon.icon_thumb_url
```
のように「フィールドっぽく（カッコなし）」アクセスできる。

---

#### ● 使いどころ

- 計算結果を「フィールドっぽく」扱いたいとき
- URL生成・合計値・変換・加工などを、テンプレートで簡単に使いたいとき

---

#### ● このモデルの場合
```python
    @property
    def icon_thumb_url(self):
        ...
        return url
```
テンプレートでは：
```html
    {{ icon.icon_thumb_url }}
```
と書くだけで、  
Cloudinary で生成されたサムネイルURLが毎回返ってくる。

> 「毎回メソッドを呼んで計算しているけど、  
>  見た目の書き心地はフィールドと同じ」

というのが @property の美味しいポイント。


## 次やること
- 一覧ページのカート合計
- 決済ページの削除ボタンを作成
- 決済ページのカート合計、小計、商品の表示


## 感じたこと
- Djangoのコンテキストプロセッサー便利すぎた。普通viewsで渡したcontextの値はそのビューでレンダリングするテンプレートでしか使えないけど、コンテキストプロセッサーにしておけば、共通の値をどのテンプレートからでも使える。グローバルな共通変数をいい感じに管理できる仕組みって感じがする
- Djangoこれやってるだけでは？！動的に表示させたい全ての処理は関数で返される。フロントからの値を引数requestなどから取得して、それを元に処理を記述。値をviewクラスならcontextに入れて、関数なら辞書で返して、テンプレに埋め込めば良い.そこにDB操作などなど絡んで来ると複雑になるのだけど
- 
## 学習時間
- 
