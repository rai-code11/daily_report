## 取り組んだ課題一覧  
- Django_udemy_s9

## わかったこと
### Djangoの動きを「ドーナツ屋 vs ラーメン屋」で理解する

#### 全体像
| たとえ | 実世界の動き | Webでの意味 |
|---|---|---|
| **ドーナツ屋（普通のWebサイト）** | できあいのドーナツを並べてお客さんに渡す | 事前に作った**静的HTML**をそのまま返す |
| **ラーメン屋（Django/API）** | 注文を聞いてから、その場で麺やスープを組み立てて提供 | リクエストごとに**データを取り出し、テンプレートに流し込んでHTML**を作って返す |

**ポイント:** Djangoは「注文が来てから作る」＝**動的生成**が基本。

#### Djangoの役割分担
- **`urls.py` = 受付（注文票）**  
  「味噌ラーメン大盛りください」= どの処理（ビュー）に回すかを決める。
- **`views.py` = 調理場の司令塔（料理人）**  
  2つの仕事をする：  
  1) **どんぶりを用意**＝**テンプレート（HTMLの型）**を選ぶ  
  2) **具材を集める**＝**`models.py`（DB）から必要なデータ**を取ってくる  
  最後に**どんぶり + 具材**で一杯にして**レスポンス**として提供。
- **`models.py` = 仕込み場（食材庫/レシピ）**  
  データベースとの橋渡し。動画・記事・ユーザーなどの**データ構造と取り出し方**を定義。
- **テンプレート = どんぶり（盛り付けの器）**  
  画面の骨組み。ビューが渡したデータを**ペタペタ差し込む**。


#### 処理の流れ
[ブラウザのリクエスト]
        │
        ▼
   urls.py（受付）
   「このURLはどの料理？」→ 対応するviewへ
        │
        ▼
   views.py（司令塔）
   ・テンプレート選ぶ（どんぶり）
   ・modelsに頼んでデータ取る（具材）
   ・テンプレートに盛り付けて完成HTMLを作る
        │
        ▼
   レスポンス（できたてをお客さんへ）


#### YouTube風の具体例（「最新の動画一覧が欲しい」）
1. **お客さんの注文**：`/videos/latest/` にアクセス  
2. **`urls.py` が解釈**：このURLは「最新動画一覧ビュー」へ回す  
3. **`views.py` が調理**：
   - 一覧表示に合う**テンプレート**を選ぶ（例：`videos/list.html`）  
   - `models.py` に「最新の動画を取ってきて」と依頼（例：`Video.objects.order_by('-published_at')[:20]`）  
4. **テンプレートへ盛り付け**：動画タイトル/サムネ/リンクを**繰り返しで差し込み**  
5. **レスポンス**：できあがったHTMLをブラウザへ返す



#### 要点のまとめ
- **静的サイト**は「作り置きを配る」。  
- **Django**は「**注文ごとに**データを取り出し、テンプレートに流し込んで**出来立てを返す**」。  
- 受付＝`urls.py`、調理＝`views.py`、食材庫＝`models.py`、どんぶり＝テンプレート。  
- だから**Djangoは“ラーメン屋さん”**の働き方と相性がいい、という理解でOK。

---
### settings.py

#### BASE_DIR 

#### ひとことで
- **BASE_DIR = プロジェクトの“基準ディレクトリ”を指す絶対パス**
- これ自体が場所を登録するのではなく、**各設定（TEMPLATES/STATIC/MEDIA/DB など）でパスを組み立てるための出発点**として使う


#### どこを指す？
通常は **`manage.py` がある階層**（プロジェクトのルート）

project_root/   ← ここが BASE_DIR  
├─ manage.py  
├─ db.sqlite3  
├─ templates/  
├─ static/  
└─ myproject/  
　├─ settings.py  
　├─ urls.py  
　└─ wsgi.py / asgi.py  

```python
from pathlib import Path
# settings.py（__file__） → 親（myproject） → さらに親（project_root）
BASE_DIR = Path(__file__).resolve().parent.parent
```

---

#### 何に使う？（代表例）

- **テンプレート置き場**：`BASE_DIR / "templates"`
- **静的ファイル**：`BASE_DIR / "static"`
- **アップロード保存先**：`BASE_DIR / "media"`
- **SQLite のDBファイル**：`BASE_DIR / "db.sqlite3"`

```python
# テンプレート設定
TEMPLATES = [{
    "BACKEND": "django.template.backends.django.DjangoTemplates",
    "DIRS": [BASE_DIR / "templates"],  # 共通テンプレート置き場
    "APP_DIRS": True,                  # 各アプリ内 templates/ も自動探索
    "OPTIONS": {"context_processors": [
        "django.template.context_processors.debug",
        "django.template.context_processors.request",
        "django.contrib.auth.context_processors.auth",
        "django.contrib.messages.context_processors.messages",
    ]},
}]

# 静的ファイル（開発時の追加パス）
STATICFILES_DIRS = [BASE_DIR / "static"]

# ユーザーアップロードの保存先
MEDIA_ROOT = BASE_DIR / "media"
MEDIA_URL = "/media/"

# SQLite（デフォルト）
DATABASES = {
    "default": {
        "ENGINE": "django.db.backends.sqlite3",
        "NAME": BASE_DIR / "db.sqlite3",
    }
}
```


### Django の DEBUG

#### 結論（使い分け）
- **DEBUG = True**：詳細なエラー画面（スタックトレース等）を表示（開発用）
- **DEBUG = False**：詳細を隠した簡易エラーページ（本番用）

#### 本番で必須・推奨の補足
- **ALLOWED_HOSTS を必ず設定**（未設定だとリクエスト拒否）
  ```python
  DEBUG = False
  ALLOWED_HOSTS = ["example.com", "www.example.com"]
  ```
- **静的ファイルはDjangoが配らない前提**  
  → `collectstatic` を実行し、Webサーバ（例：Nginx）で配信
- **エラーページを用意**  
  → `templates/404.html`、`templates/500.html`
- **セキュリティ設定を有効化（可能なら）**  
  → `SECURE_HSTS_SECONDS` / `SECURE_SSL_REDIRECT` / `SESSION_COOKIE_SECURE` など

#### まとめ
- 開発中は **`DEBUG=True`**  
- 公開時は **`DEBUG=False` + `ALLOWED_HOSTS` 他の本番設定** が正解


---

### INSTALLED_APPS 

## 一言で
- **このプロジェクトで使うアプリの“出席簿”**。  
- ここに登録したアプリだけが **Django に認識・読み込み** される（モデル、管理画面、シグナル、テンプレート探索などが有効化）。


#### 何を入れる？
1. **Django標準アプリ**：`admin`, `auth`, `sessions`, `staticfiles` など  
2. **自作アプリ**：例 `todo`  
3. **外部アプリ**：例 `rest_framework`, `allauth` など


#### いつ書く？
- `python manage.py startapp appname` で **自作アプリを作った直後**  
- `pip install` した **外部アプリを使うとき**

#### 書き方（推奨）
```python
# settings.py
INSTALLED_APPS = [
    # --- Django標準 ---
    "django.contrib.admin",
    "django.contrib.auth",
    "django.contrib.contenttypes",
    "django.contrib.sessions",
    "django.contrib.messages",
    "django.contrib.staticfiles",

    # --- 自作アプリ ---
    "todo.apps.TodoConfig",  # ← AppConfig形式で登録（推奨）

    # --- 外部アプリ ---
    # "rest_framework",
]
```
- `"todo"` と短く書くことも可能だが、**`"todo.apps.TodoConfig"` の方が安全**（初期化や `ready()` が確実に効く）。

#### 書かないとどうなる？
- `makemigrations` が **モデルを検出しない** → `No changes detected`  
- 管理画面に **モデルが出ない**  
- シグナルや設定が **読み込まれない**


#### 補足
- テンプレートは `TEMPLATES[0]["APP_DIRS"] = True` のとき、**`INSTALLED_APPS` に登録済みアプリの `templates/`** も自動探索される。  
- アプリを追加/削除した後は、必要に応じて **`python manage.py migrate`** でDBを最新化。


### Django Middleware の本当の基本

- **何者？**  
  リクエスト→ビュー→レスポンスの“通り道”で **共通処理** を行う仕組み。

- **どこで設定？**  
  `settings.py` の **`MIDDLEWARE` リスト** に並べる。**順番が重要**（上から行き、下から戻る）。

- **代表例（よく使う順）**  
  - `SessionMiddleware`：セッション管理（`request.session`）  
  - `CsrfViewMiddleware`：CSRF対策  
  - `AuthenticationMiddleware`：認証情報（`request.user`）  
  - `MessageMiddleware`：フラッシュメッセージ  
  - `SecurityMiddleware`：各種セキュリティヘッダ

- **使いどころの見分け方**  
  - **全ページ共通**で効かせたい → **Middleware**  
  - **特定ビューだけ**で使いたい → **ビューやデコレータ（`@login_required` など）**


### ROOT_URLCONF 

#### 一言で
- **最初に読む URL ルーティングの場所**を Django に教える設定。
- ブラウザから来たURLを、まず **どの `urls.py` で受けるか** を決める。

#### どこに書く？
```python
# settings.py
ROOT_URLCONF = "helloworldproject.urls"  # 例：<プロジェクト名>.urls
```

#### 典型的な構成
project_root/  
├─ manage.py  
└─ helloworldproject/      ← プロジェクト名（=パッケージ名）  
　├─ settings.py  
　├─ urls.py               ← ここを ROOT_URLCONF が指す  
　└─ wsgi.py / asgi.py  

#### 具体例
```python
# helloworldproject/urls.py
from django.contrib import admin
from django.urls import path, include

urlpatterns = [
    path("admin/", admin.site.urls),  # 管理画面
    path("", include("todo.urls")),   # ルート配下は todo アプリへ委譲
]
```

```python
# todo/urls.py
from django.urls import path
from . import views

urlpatterns = [
    path("list/", views.TodoList.as_view(), name="todo_list"),
]
```

#### リクエストの流れ
ブラウザのURL  
→ **ROOT_URLCONF**（例：`helloworldproject.urls`）  
→ `path()` / `include()` で各アプリの `urls.py` へ  
→ `views.py`（処理）  
→ レスポンス

#### つまずきやすいポイント
- **モジュールパスのミス**：`"myproject.urls"` のスペル・階層を確認  
- **プロジェクト名変更後**に `ROOT_URLCONF` の更新忘れ  
- トップは薄く、**詳細な振り分けはアプリ側 `urls.py` に委譲**するのが定石

---
### Django設定メモ：`TEMPLATES` / `DATABASES` / `AUTH_PASSWORD_VALIDATORS`

> ※「DATEBASES」は誤記。正しくは **`DATABASES`**。

#### TEMPLATES（テンプレート設定）
- **役割**：Djangoが**どこからテンプレートを探すか**、どう処理するかを定義。
- **主なキー**
  - `DIRS`：共通テンプレート置き場（例：`BASE_DIR / "templates"`）
  - `APP_DIRS`：各アプリ内 `templates/` を自動探索（通常 `True`）
  - `OPTIONS.context_processors`：全テンプレに自動で渡す共通値
- **最小例**
```python
from pathlib import Path
BASE_DIR = Path(__file__).resolve().parent.parent

TEMPLATES = [{
    "BACKEND": "django.template.backends.django.DjangoTemplates",
    "DIRS": [BASE_DIR / "templates"],
    "APP_DIRS": True,
    "OPTIONS": {"context_processors": [
        "django.template.context_processors.debug",
        "django.template.context_processors.request",
        "django.contrib.auth.context_processors.auth",
        "django.contrib.messages.context_processors.messages",
    ]},
}]
```



#### DATABASES（DB接続設定）
- **役割**：Djangoが**どのデータベースに接続するか**を定義。
- **ポイント**：`ENGINE`（種類）と `NAME`（DB名/ファイル）が中心。必要に応じて `USER`/`PASSWORD`/`HOST`/`PORT`。
- **例：SQLite（開発標準）**
```python
DATABASES = {
    "default": {
        "ENGINE": "django.db.backends.sqlite3",
        "NAME": BASE_DIR / "db.sqlite3",
    }
}
```
- **例：PostgreSQL（本番でよく使用）**
```python
DATABASES = {
    "default": {
        "ENGINE": "django.db.backends.postgresql",
        "NAME": "mydb",
        "USER": "myuser",
        "PASSWORD": "secret",
        "HOST": "127.0.0.1",
        "PORT": "5432",
    }
}
# ドライバ（例：psycopg）をインストールし、migrate を実行
```


#### AUTH_PASSWORD_VALIDATORS（パスワード強度）
- **役割**：ユーザー登録/変更時の**パスワード検証**をまとめて管理。
- **主なビルトイン**
  - `UserAttributeSimilarityValidator`：ユーザー属性に似すぎるPWを禁止
  - `MinimumLengthValidator`：最小文字数（`OPTIONS`で変更可能）
  - `CommonPasswordValidator`：よくある弱いPWを禁止
  - `NumericPasswordValidator`：数字のみのPWを禁止
- **最小例**
```python
AUTH_PASSWORD_VALIDATORS = [
    {"NAME": "django.contrib.auth.password_validation.UserAttributeSimilarityValidator"},
    {"NAME": "django.contrib.auth.password_validation.MinimumLengthValidator",
     "OPTIONS": {"min_length": 8}},
    {"NAME": "django.contrib.auth.password_validation.CommonPasswordValidator"},
    {"NAME": "django.contrib.auth.password_validation.NumericPasswordValidator"},
]
```



### `urls.py` と `urlpatterns` の基本（Django）—「プロジェクト→アプリへ委譲」のニュアンス付き

#### 要点
- **`urlpatterns`**：**URL → 処理先**（ビュー or さらに別の URL 表）を対応づける**ルーティング表**。この名前で Django が読み取る。
- **`path(パターン, 処理先)`**：
  - 第1引数：`"admin/"` のような **URL のパスパターン**（「リクエストそのもの」ではない）
  - 第2引数：**処理先**
    - ビュー関数/クラス（例：`views.hello`）
    - **別の URL 設定へ委譲**（例：`include("blog.urls")`）
    - **管理サイトの URL 一式**（`admin.site.urls`）


#### 「別のURL設定へ委譲」の正しいイメージ
- **プロジェクトの `urls.py` でいったん受け取ってから、アプリの `urls.py` に“残りのパス”を流す**。
- 例：`/blog/list/` というリクエストなら  
  1) **プロジェクト側**が `blog/` までをマッチ  
  2) **アプリ側（`blog/urls.py`）** に **残りの `list/`** を渡して解決

フロー図：
```
/blog/list/ というURL
   ├─ project/urls.py で "blog/" をマッチ → include("blog.urls") に委譲
   └─ blog/urls.py が 残りの "list/" をマッチ → 対応する view を実行
```

---

#### `path("admin/", admin.site.urls)` はこう動く
- ブラウザが **`/admin/login/`** にアクセス
  1. 先頭の `"admin/"` にマッチ → **`admin.site.urls`（管理サイト用の URL 表）へ委譲**
  2. 残りの `"login/"` を**管理サイト側の URL 表**で解決
  3. 対応ビューが実行され、レスポンスを返す

> つまり「`admin/` が来たら **管理サイトの“URL表”に渡す**」。  
> `admin.site.urls` は **views.py の中身**ではなく、**URL 設定の束**。

#### よくある勘違いの修正
- **「`admin`（前半）がリクエスト」→ ×**  
  第1引数は **URL のパターン**。リクエストそのものではない。
- **「`admin.site.urls` が views.py の中身」→ ×**  
  これは **管理サイトの URL 設定一式**。そこへ**委譲**している。
- **変数名は `url patterns`？ → ×**  
  正しくは **`urlpatterns`**（小文字・複数形・綴りに注意）。

---


### Djangoのリクエスト処理の流れと `views.py` の役割

- **`views.py` の仕事**：受け取った **`HttpRequest`** を読み、必要な処理（DBアクセス・テンプレ描画・JSON生成など）をして **`HttpResponse`** を返す。
- **Django（フレームワーク）の仕事**：ブラウザからのリクエストを受け取り **`HttpRequest` を生成 → ルーティング（`urls.py`）で行き先を決定 → `view` を呼ぶ → 返ってきた `HttpResponse` を最終的にサーバ（WSGI/ASGI）へ返す**。

---


### FBV vs CBV

| 種別 | たとえ | 特徴 |
|---|---|---|
| **Function-Based View (FBV)** | **普通のキッチン** | 一皿ごとに手で調理。**柔軟で細かく制御**しやすいが、コードが長くなりがち。 |
| **Class-Based View (CBV)** | **システムキッチン** | オーブンに入れる感覚で**共通パターンを少ないコードで**実装。デフォルトはお任せ。ただし**必要ならメソッドをオーバーライドして細かく調整も可能**。 |

#### 使い分けの目安
- **まずCBV**：一覧・詳細・作成・更新・削除など定番CRUDは速い  
- **FBV**：処理の流れを細かく握りたい／一風変わった挙動を作り込みたいとき


### `template_name` とテンプレートの置き場所（Django）

#### 何ができる？
- `template_name` に **使いたい HTML ファイル**を指定すると、そのテンプレートを描画します。

```python
# views.py
from django.views.generic import TemplateView

class HomePageView(TemplateView):
    template_name = "hello.html"  # ← このテンプレートを使う
```

#### どこに置けば読まれる？
**次のどちらか**に置く必要があります（“どこでも”ではありません）。

1) **プロジェクト共通のテンプレ置き場**  
   `project_root/templates/hello.html`

2) **アプリ内の templates/**  
   - 例1: `myapp/templates/hello.html`
   - 例2: `myapp/templates/myapp/hello.html`（重複回避のため**名前空間**を切るのが安全）  
     → `template_name="myapp/hello.html"` のように指定

## 次やること
- Django_udemy_s11,12

## 感じたこと
- 難しそうな内容でも身近なものを例にするとすんなり入ってきてしかも忘れづらい
- これまでの知識を総動員するのでしっかりと1つ1つ理解を深めながら進んでいく

## 学習時間
- 3.10h
