## 取り組んだ課題一覧  
- Python
  - 自販機_PR
  - ポケモン_PR

## わかったこと
### クラス内でリストを作る関数の注意点

#### 1. 関数は呼ばないと実行されない
- `createPokemon100()` を呼ばないと `self.pokemons` は作られない  
- 呼んで初めてリストが生成され、`self.pokemons` が使えるようになる  

#### 2. 属性が存在しないとエラーになる
- `self.pokemons` が無い状態で `self.pokemons[0]` を呼ぶと `AttributeError`  

#### 3. 使い方の流れ
1. まずリストを作る関数を呼ぶ  
2. その後でリストを利用する  

```python
class Pokemon:
    def __init__(self):
        self.name = "リザードン"
        self.type1 = "ほのお"
        self.type2 = "ひこう"
        self.hp = 100

    def attack(self):
        print(f"{self.name}のこうげき")

    def createPokemon100(self):
        self.pokemons = []
        for _ in range(100):
            poke = Pokemon()
            self.pokemons.append(poke)
        return self.pokemons


# 実行
poke = Pokemon()
poke.createPokemon100()   # リスト生成
print(poke.pokemons[0].name)   # => リザードン
poke.pokemons[99].attack()     # => リザードンのこうげき
```


### del と __del__（デストラクタ）のまとめ

#### del の役割
- 変数やオブジェクトの参照を削除する  
- 実体（メモリ上のオブジェクト）は、参照がなくなった時点でガベージコレクションにより破棄される  

```python
x = [1, 2, 3]
del x        # 参照を削除
# print(x)   # エラー: NameError
```

---

#### __del__（デストラクタ）
- オブジェクトが破棄されるときに自動で呼ばれるメソッド  
- ただし「いつ呼ばれるか」は保証されない（GC次第）  

```python
class Pokemon:
    def __init__(self, name):
        self.name = name

    def __del__(self):
        print(f"{self.name} が消えた！")

p = Pokemon("ピカチュウ")
del p   # => ピカチュウ が消えた！
```

---

#### 注意点
- `del` = 参照削除  
- `__del__` = インスタンス破棄時に動く処理  
- ファイル/DB 接続などのリソース解放は `with` 文や明示的な `close()` を用いる  

---

#### まとめ
- `del` は「変数名（参照）を消す」  
- `__del__` は「オブジェクトが破棄されるときの後処理」  


### Pythonで子クラスから親メソッドを呼ぶ方法

#### super() を使う（基本）
- `super().メソッド名()` で親メソッドを呼び出す
- 親の処理を残しつつ、子の処理を追加できる

```python
class Parent:
    def greet(self):
        print("親クラスです")

class Child(Parent):
    def greet(self):
        super().greet()      # 親メソッド呼び出し
        print("子クラスです")

c = Child()
c.greet()
# => 親クラスです
# => 子クラスです
```

#### メモ
- Pythonではオーバーライドは同名メソッドを定義し直すだけでOK
- 特別な記号やアノテーションは不要
- `__init__` でも同様に `super().__init__(...)` で親の初期化を再利用


### インターフェース的な使い方と多重継承のポイント（メモ）

#### インターフェースとは
- **実装を持たずメソッドだけを宣言**するクラスのこと  
- サブクラスに「必ずこのメソッドを実装せよ」という**契約**を課す  

```python
class PokemonAttack:
    def attack(self):
        raise NotImplementedError("サブクラスで実装してください")
```

---

#### メリット
1. **実装の強制**  
   - サブクラスは必ず `attack` を実装しないとエラーになる  
   - → メソッドの存在を保証でき、設計がブレにくい  

2. **一貫性の確保**  
   - どのサブクラスでも同じメソッド名で呼び出せる  
   - 例：`pika.attack()` も `liza.attack()` も必ず動く  

3. **柔軟な組み合わせ（多重継承）**  
   - 複数のインターフェースをまとめて継承し、機能を合成できる  
   - 例：`Pikachu` も `Lizardon` も「攻撃・防御・逃走」を持つ  

4. **多重クラス設計にも応用できる**  
   - インターフェースを細かく分けて設計すれば、  
     「攻撃できる飛行ポケモン」「守れるけど攻撃できないポケモン」など、  
     **複数の組み合わせパターンを安全に作れる**

---

#### サンプル（今回のコード）
```python
class Pikachu(PokemonAttack, PokemonProtect, PokemonRunAway):
    def attack(self):  print("ピカチュウの１０万ボルト！")
    def protect(self): print("ピカチュウはかみなりで身を守った！")
    def run_away(self): print("ピカチュウは電光石火で逃げた！")

class Lizardon(PokemonAttack, PokemonProtect, PokemonRunAway):
    def attack(self):  print("リザードンのかえんほうしゃ！")
    def protect(self): print("リザードンは翼で身を守った！")
    def run_away(self): print("リザードンは空を飛んで逃げた！")
```

---

#### まとめ
- インターフェースは**メソッドの存在を強制**する仕組み  
- サブクラスは「必ずこのメソッドを持つ」ので安心して呼び出せる  
- 複数のインターフェースを継承して**機能を自由に組み合わせ**られる  
- **多重クラス設計にも有効**で、必要な機能を安全に組み合わせて柔軟に設計できる  

## 次やること
- SQL

## 感じたこと
- クラスをインターフェース的な使い方をしてサブクラスに設計命令を出したり、それを細かく分けて多重継承して機能を合成出来たりするのはおもろいなあと思った
- 瞬きをあまりしなかったからか目の下にしこりができてきたので定期的に瞬きして目を潤す。

## 学習時間
- 8.00h
