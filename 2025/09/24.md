## 取り組んだ課題一覧  
- udemy_s13
- Django_教科書

## わかったこと
### Django：ビューとレンダリング（TemplateResponse 版の要点）

#### サンプルコード
```python
from django.template.response import TemplateResponse

def hello(request):
    if request.method == "GET":
        context = {"message": "Hello World!"}
        return TemplateResponse(request, "hello.html", context)
```

#### テンプレート例（参考）
```html
<!-- templates/hello.html -->
<p>{{ message }}</p>
```

#### 処理の流れ
1. **リクエスト受取**  
   `hello(request)` で `HttpRequest` を受け取る。`request.method` で `"GET"` かなどを判定。
2. **条件分岐**  
   `if request.method == "GET":` なら以下を実行。
3. **コンテキスト準備**  
   `context = {"message": "Hello World!"}` をテンプレートへ渡すデータとして用意。
4. **TemplateResponse 生成（まだ未レンダリング）**  
   `TemplateResponse(request, "hello.html", context)` を返す時点では**最終HTMLは未生成**。
5. **返却とレンダリング**  
   Django がレスポンスを返す段階でテンプレートが**レンダリング**され、完成したHTMLがブラウザへ送られる。

#### 用語ミニメモ
- **レンダリング**：テンプレート + データ ⇒ 最終HTMLに“仕上げる”処理  
- **TemplateResponse**：**遅延レンダリング**（あとで `.render()` タイミングでHTML化）  
- **render() との比較**：`render()` は**即時レンダリング**して `HttpResponse` を返す


### Djangoにおける render() と TemplateResponse の使い分け

#### render()
- テンプレートを即座にレンダリングして、完成した **HttpResponse** を返す。
- 一般的な「画面を表示する」処理はこれで十分。
- サンプルコード

```python
from django.shortcuts import render

def hello(request):
    context = {"message": "Hello World!"}
    return render(request, "hello.html", context)
```

#### TemplateResponse
- 返す時点ではまだ HTML に変換されていない。
- **レンダリング前にミドルウェアやフックで処理を追加・加工したい場合**に利用する。
- Django がレスポンスを返す直前にレンダリングされ、最終的な HTML が生成される。
- サンプルコード

```python
from django.template.response import TemplateResponse

def hello(request):
    if request.method == "GET":
        context = {"message": "Hello World!"}
        return TemplateResponse(request, "hello.html", context)
```

#### 使い分けの考え方
- **render()**  
  即時に完成した HTML を返す。通常はこちらを使う。

- **TemplateResponse**  
  HTML 化される前に設定や加工を加えたい場合に使う。


#### まとめ
- HTML 化する前に追加処理をしたい → TemplateResponse  
- 普通に完成 HTML を返すだけでよい → render()


### django.shortcuts.redirect()

#### 何をする？
- ブラウザに「別のURLへ移動してください」と指示するレスポンスを返す関数。
- デフォルトは **302（Temporary Redirect: 一時的リダイレクト）**。
- 引数に `permanent=True` を指定すると **301（Permanent Redirect: 恒久的リダイレクト）** になる。


#### サンプルコード

```python
from django.shortcuts import redirect

def to_google(request):
    return redirect("https://www.google.com")   # 絶対URLへ

def to_home(request):
    return redirect("home")                     # 名前付きURLパターンへ

def to_detail(request, pk):
    return redirect("post_detail", pk=pk)       # 名前付きURL + 引数
```


#### 引数に指定できるもの
- **絶対URL**  
  例: `"https://example.com"`
- **名前付きURLパターン**  
  `urls.py` で `name="home"` を定義していれば `redirect("home")` で遷移可能。
- **モデルインスタンス**  
  モデルに `get_absolute_url()` を実装していれば、`redirect(my_object)` でそのURLに飛べる。

#### よくある用途
- **フォーム送信後のリダイレクト（PRGパターン）**  
  `POST` 後にそのままテンプレートを返すと、再読み込みで二重送信の恐れがある。  
  そのため処理が終わったら `redirect()` を使って別の画面に移動させる。

```python
from django.shortcuts import render, redirect

def create_post(request):
    if request.method == "POST":
        # バリデーション & 保存処理...
        return redirect("post_list")   # 一覧ページへリダイレクト
    return render(request, "post_form.html")
```

#### まとめ
- `redirect()` は **別URLへ移動させるレスポンス** を返す関数。  
- デフォルトは 302、一時的リダイレクト。  
- `permanent=True` を指定すると 301、恒久的リダイレクトになる。  
- 主に **フォーム送信後の遷移（PRGパターン）** で使う。


### Django クラスベースビュー（HelloView の解説）

#### コード例
```python
from django.template.response import TemplateResponse
from django.views import View

class HelloView(View):
    def get(self, request, *args, **kwargs):
        context = {
            'message': "Hello World!",
        }
        return TemplateResponse(request, 'hello.html', context)

hello = HelloView.as_view()
```

#### インポート部分
- `TemplateResponse`  
  テンプレートとコンテキストを組み合わせて HTML を生成するレスポンスオブジェクト。  
- `View`  
  Django のクラスベースビューの基底クラス。  
  継承して HTTP メソッドごとに処理を定義できる。

#### クラス定義
```python
class HelloView(View):
```
- `View` を継承して新しいビュークラスを作成。

#### get メソッド
```python
def get(self, request, *args, **kwargs):
    context = {
        'message': "Hello World!",
    }
    return TemplateResponse(request, 'hello.html', context)
```
- `get()`  
  - HTTP リクエストが `GET` の場合に呼ばれるメソッド。  
- 引数  
  - `request`: ブラウザから送られてきたリクエスト情報。  
  - `*args, **kwargs`: URL で渡された追加パラメータを受け取れる。  
- 処理内容  
  1. `context` にテンプレートへ渡すデータを用意。  
  2. `TemplateResponse` を返し、`hello.html` にデータを埋め込む。


#### as_view() の利用
```python
hello = HelloView.as_view()
```
- クラスを「ビュー関数のように呼び出せるオブジェクト」に変換。  
- `urls.py` に登録して使う。

例:
```python
from django.urls import path
from .views import hello

urlpatterns = [
    path("hello/", hello, name="hello"),
]
```

#### ポイントまとめ
- クラスベースビューでは **HTTP メソッドごとにメソッドを分けて書ける**（`get` / `post` など）。  
- `TemplateResponse` を使えば **コンテキスト + テンプレート** でレスポンスを返せる。  
- `as_view()` によって **URL に登録できる関数形式** に変換される。


### Django クラスベースビュー（CBV）
#### 基本汎用ビュー
- **View**（django.views.generic.base.View）
  - CBV の基底クラス
- **TemplateView**（django.views.generic.base.TemplateView）
  - 指定したテンプレートを表示するビュー
- **RedirectView**（django.views.generic.base.RedirectView）
  - 指定したURLにリダイレクトするビュー


#### 汎用ビュー
- **ListView**（django.views.generic.list.ListView）
  - モデルの一覧表示
- **DetailView**（django.views.generic.detail.DetailView）
  - モデルの詳細表示
- **FormView**（django.views.generic.edit.FormView など）
  - フォーム入力・送信を処理
- **ArchiveIndexView**（django.views.generic.dates.ArchiveIndexView など）
  - 日付ベースのデータを一覧表示


#### 認証系ビュー
- **LoginView**（django.contrib.auth.views.LoginView など）
  - 認証用のログイン画面を提供

## 次やること
- Django_教科書
- 

## 感じたこと
- 朝の時間に勉強できないと1日8時間やることは大変になる。
- Django難しいなあと思っていたけど、Djangoの本がわかりやすくて簡単に感じる。わかりやすい説明の有り難みを感じる。

## 学習時間
- 8.45h
