
## 取り組んだ課題一覧  
- DB設計完読

## わかったこと
### やってはいけない論理設計（アンチパターン）

#### 1. 非スカラ値
- **内容**: 1つのセルに2つ以上の値を入れる  
- **例**: 「電話番号」列に `090-xxxx,080-xxxx` を保存  
- **問題**: 検索や更新が困難（正規化の原則違反）  
- **改善**: 値ごとに行を分けるか、別テーブルにする  

---

#### 2. ダブルミーニング
- **内容**: 1つの列に途中から別の意味を持たせる  
- **例**: 「体重」列に年齢を入れるようにした  
- **問題**: 列の意味が一貫せず、過去データと新データを一緒に扱えない  
- **改善**: 意味ごとに列を分ける（体重列と年齢列を別にする）  

#### 3. 単一参照テーブル
- **内容**: すべてのコード値やマスタ値を1つの巨大テーブルにまとめる  
  例: `コードマスタ(コード種別, コード値, コード名)` に「性別」「都道府県」「ステータス」など全部入れる  

- **問題**:
  - 列の意味が1つに統一されず、テーブルの責務があいまいになる  
  - 「コード種別」で毎回絞り込む必要があり、クエリの可読性が悪い  
  - データの整合性チェック（外部キー制約）が使えない  
    - 例: 性別カラムに「都道府県コード」が入ってもDB的には検知できない  

- **改善**:
  - 種別ごとにマスタを分ける  
    - 性別マスタ  
    - 都道府県マスタ  
    - ステータスマスタ  
  - それぞれのテーブルに外部キーを貼れるようにすることで、整合性が保証される  

### 4. テーブル分割
#### 水平分割の欠点
1. **意味的な理由がない**
   - 「2024年注文」「2025年注文」のように年で分けても、データの意味は同じ  
   - 本来1つのテーブルで持つべきものを無理に分けてしまう  

2. **拡張性に乏しい**
   - 年ごとにテーブルを増やすと、将来さらに「2026年注文」「2027年注文」と際限なく増える  
   - 新しい分割が必要になるたびにアプリやSQLを書き換える必要が出る  

3. **代替手段がある**
   - ほとんどのDBは **パーティション機能** を持っているので、論理的には1テーブルのまま扱える  
   - インデックスやアーカイブ、ビューを活用すればパフォーマンスを確保できる  

#### 垂直分割の欠点
1. **意味的な理由がない**
   - 「ユーザー基本情報」と「ユーザー詳細情報」に分けるような設計をするが、結局は1人のユーザーという同じ意味を持つ  
   - 「1テーブルで表現できるもの」を不自然に分けてしまっている  

2. **拡張性に乏しい**
   - 「よく一緒に使う列」を分けてしまうと、アプリ側で毎回 JOIN が必要になる  
   - 利用シーンが増えるほど結合が複雑化し、将来の拡張に対応しづらい  

3. **代替手段がある**
   - 論理的には1テーブルにまとめておき、必要に応じて **ビュー** や **集約テーブル** で対応すれば十分  
   - アクセス頻度の低いデータは別のストレージに移すなど、物理設計で工夫できる  

#### 5. 不適切なキー
- **内容**: 主キーに可変長文字列を使う（例: メールアドレス、名前）  

- **問題点**:
  1. **値が変わる可能性がある**  
     - メールアドレスや名前はユーザーが変更できる  
     - 主キーが変わると外部キーも連鎖的に修正が必要になり、整合性が崩れる  

  2. **検索効率が悪い**  
     - 可変長文字列はサイズが大きく、インデックス効率が低い  
     - 数値型や固定長よりも検索・JOINが遅くなる  

- **改善**:
  - 主キーは **短く・不変な値（数値ID, UUIDなど）** を使う  
  - 可変長文字列は「ユニーク制約」をかけて **候補キー** として利用する  
    - 例: `users(id(PK), email(Unique), name, ...)`


## 次やること
- DB設計記事
- DB演習

## 感じたこと
- 休日に少しでもできたのは良かったが、休日はしっかり休めるように勉強時間を調整したい。
- 朝の学習開始時間を早めていきたい。できれば、8時半〜9時までには始めたい。

## 学習時間
- 1.10h
