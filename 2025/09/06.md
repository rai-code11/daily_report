## 取り組んだ課題一覧  
- Udemey_自動販売機

## わかったこと
### Pythonのgetter / setter と引数の違いまとめ

#### ■ getter
- **役割**: 今の状態を返すだけ  
- **引数**: `self` のみ  
- **戻り値**: 内部にある値  

```python
class Person:
    def __init__(self, age):
        self._age = age

    @property
    def age(self):  # getter
        return self._age

p = Person(20)
print(p.age)  # getterが呼ばれる → 20
```

---

#### ■ setter
- **役割**: 新しい値を入れるときに呼ばれる  
- **引数**: `self` ＋ 「新しい値」  
- **処理**: バリデーション（値のチェック）を行い、OKなら内部変数に代入  

```python
class Person:
    def __init__(self, age):
        self._age = age

    @property
    def age(self):
        return self._age

    @age.setter
    def age(self, value):  # setter
        if value < 0:
            raise ValueError("年齢は0未満にできません")
        self._age = value

p = Person(20)
p.age = 30    # setterが呼ばれて value=30 が渡される
print(p.age)  # → 30

p.age = -5    # setterが呼ばれて value=-5 が渡される → エラー
```

---

#### ■ なぜ必要か？
1. **不正な値を防ぐ**  
   例：`age = -5`（ありえない年齢）、`balance = -1000`（マイナス残高）

2. **内部の仕組みを隠せる（カプセル化）**  
   見た目は `obj.age` / `obj.age = 20` のまま、裏でチェックを挟める

3. **コードが読みやすい**  
   関数呼び出し（`get_xxx` / `set_xxx`）より自然な記法になる  

---

#### ■ まとめ
- **getter** = `def xxx(self):`  
  → `self` しか取らない  
  → 「今の状態を返すだけ」  

- **setter** = `def xxx(self, value):`  
  → `self` と「新しい値」を取る  
  → 「代入のときに呼ばれて、値をチェックしてから保存する」  

- **メリット**  
  - 不正な値を防ぐ  
  - 内部の仕組みを隠せる（カプセル化）  
  - 記法が自然でコードが読みやすい  


### PythonのPublic / Protected / Private変数まとめ

#### Public変数
```python
class Person:
    def __init__(self, name):
        self.name = name  # Public
```

- 名前: `name`  
- アクセス: どこからでも可能  
- 制限なし（自由に読み書きできる）

```python
p = Person("Takuma")
print(p.name)   # OK
p.name = "rai"  # OK
```

---

#### Protected変数
```python
class Person:
    def __init__(self, name):
        self._name = name  # Protected
```

- 名前: `_name`（先頭にアンダースコア1つ）  
- アクセス: 外からも可能（エラーは出ない）  
- 実際には制御されていない  
- 「内部用だから直接触らないで」という慣習（マナー）

```python
p = Person("Takuma")
print(p._name)   # 実はOK
p._name = "rai"  # 実はOK
```

---

#### Private変数
```python
class Person:
    def __init__(self, name):
        self.__name = name  # Private

    def get_name(self):     # クラス内のメソッド
        return self.__name
```

- 名前: `__name`（先頭にアンダースコア2つ）  
- アクセス: クラスの外からは直接アクセス不可  
- 裏で「名前マングリング」され、`_クラス名__変数名` に変換される  

```python
p = Person("Takuma")

print(p.get_name())   # OK（クラス内メソッドからアクセス）

print(p.__name)       # AttributeError
print(p._Person__name)  # 名前マングリングを使えばアクセスできる
```

---

#### 補足
- PythonはJavaやC++のように厳密なアクセス制御を持たない  
- `_` や `__` は「人間へのサイン」＋「多少の制御」にすぎない  
- 本当に値を守りたい場合は `@property` + setter/getter でバリデーションを組み合わせる


### Pythonの@propertyを別クラスから利用する簡単な例

#### Userクラス（情報を持つ側）
```python
class User:
    def __init__(self, name, age):
        self.__name = name   # プライベート変数
        self.__age = age

    @property
    def name(self):          # 読み取り専用のプロパティ
        return self.__name

    @property
    def age(self):
        return self.__age
```

---

#### Profileクラス（Userの情報を使う側）
```python
class Profile:
    def __init__(self, user):
        self.user = user     # Userインスタンスを受け取る

    def show_profile(self):
        # propertyを変数のようにアクセス
        return f"{self.user.name} さんは {self.user.age} 歳です"
```

---

#### 実行例
```python
user = User("Takuma", 28)     # Userインスタンス作成
profile = Profile(user)      # Profileに渡す

print(profile.show_profile())
# → "Takuma さんは 28 歳です"
```

---

#### ポイント
- `User` クラスは **@property** を使って `name` と `age` を公開  
- `Profile` クラスは `self.user.name` / `self.user.age` のように **変数アクセスで使える**  
- 外から見ると属性アクセスに見えるが、裏ではメソッドが呼ばれている

## 次やること
- Python_自動販売機

## 感じたこと
- Python_ポケモンで学ぶ

## 学習時間
- 5.15h
