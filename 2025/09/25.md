## 取り組んだ課題一覧  
- Django_教科書
- Django_公式チュートリアル

## わかったこと
### Django モデル解説：Book クラス

```python
from django.db import models  

class Book(models.Model):
    """ 本 モデル """

    class Meta:
        # テーブル名を定義
        db_table = 'book'

    # テーブルのカラムに対応するフィールドを定義
    title = models.CharField(verbose_name='タイトル', max_length=255, unique=True)
    price = models.IntegerField(verbose_name='価格', null=True, blank=True)

    def __str__(self):
        return self.title
```

**解説**

**1. クラス定義**
- `class Book(models.Model):`  
  Django のモデルクラス。`models.Model` を継承することで DB テーブルとして扱われる。

**2. Meta クラス**
- `class Meta:` はモデルに関するメタデータを定義。  
- `db_table = 'book'`  
  → テーブル名を `book` に固定。

**3. フィールド**
- `title = models.CharField(...)`  
  - 文字列フィールド  
  - `verbose_name='タイトル'` → 管理画面でのラベル名  
  - `max_length=255` → 文字数制限  
  - `unique=True` → ユニーク制約（同じタイトルは登録不可）

- `price = models.IntegerField(...)`  
  - 整数フィールド  
  - `verbose_name='価格'` → 管理画面でのラベル名  
  - `null=True` → DB 上で NULL を許可  
  - `blank=True` → フォームで空欄を許可

**4. __str__ メソッド**
- インスタンスを文字列化したときの見え方を定義。  
- `return self.title` により、管理画面やシェルで `print(book)` とするとタイトルが表示される。

**まとめ**
- `Book` モデル = DB の `book` テーブルを表す。  
- `title` と `price` がテーブルのカラムに対応。  
- `__str__` によってインスタンスを扱いやすく文字列表示できる。

---

### Django モデル解説：Book クラス

```python
from django.db import models  

class Book(models.Model):
    """ 本 モデル """

    class Meta:
        # テーブル名を定義
        db_table = 'book'

    # テーブルのカラムに対応するフィールドを定義
    title = models.CharField(verbose_name='タイトル', max_length=255, unique=True)
    price = models.IntegerField(verbose_name='価格', null=True, blank=True)

    def __str__(self):
        return self.title
```


**解説**

**1. クラス定義**
- `class Book(models.Model):`  
  Django のモデルクラス。`models.Model` を継承することで DB テーブルとして扱われる。

**2. Meta クラス**
- `class Meta:` はモデルに関するメタデータを定義。  
- `db_table = 'book'`  
  → テーブル名を `book` に固定。

**3. フィールド**
- `title = models.CharField(...)`  
  - 文字列フィールド  
  - `verbose_name='タイトル'` → 管理画面でのラベル名  
  - `max_length=255` → 文字数制限  
  - `unique=True` → ユニーク制約（同じタイトルは登録不可）

- `price = models.IntegerField(...)`  
  - 整数フィールド  
  - `verbose_name='価格'` → 管理画面でのラベル名  
  - `null=True` → DB 上で NULL を許可  
  - `blank=True` → フォームで空欄を許可

**4. __str__ メソッド**
- インスタンスを文字列化したときの見え方を定義。  
- `return self.title` により、管理画面やシェルで `print(book)` とするとタイトルが表示される。


**まとめ**
- `Book` モデル = DB の `book` テーブルを表す。  
- `title` と `price` がテーブルのカラムに対応。  
- `__str__` によってインスタンスを扱いやすく文字列表示できる。

---

### Django モデル解説：Publisher（出版社）と Book（本）

```python
from django.db import models  

class Publisher(models.Model):
    """出版社モデル"""

    class Meta:
        db_table = 'publisher'

    name = models.CharField(verbose_name='出版社名', max_length=255)


class Book(models.Model):
    """本モデル"""

    class Meta:
        db_table = 'book'

    title = models.CharField(verbose_name='タイトル', max_length=255)
    publisher = models.ForeignKey(
        Publisher,
        verbose_name='出版社',
        on_delete=models.PROTECT
    )
```

**解説**
 
**Publisher モデル**
- 出版社を表すテーブル。  
- `db_table = 'publisher'` → テーブル名を `publisher` に設定。  
- `name` → 出版社名を文字列（最大255文字）で保存。  

例（publisher テーブル）:
```
id   name
1    講談社
2    集英社
```

**Book モデル**
- 本を表すテーブル。  
- `db_table = 'book'` → テーブル名を `book` に設定。  
- `title` → 本のタイトル。  
- `publisher = models.ForeignKey(...)`
  - 外部キーで Publisher モデルを参照。  
  - `verbose_name='出版社'` → 管理画面でのラベル。  
  - `on_delete=models.PROTECT` → 出版社が参照されている場合は削除不可。  

例（book テーブル）:
```
id   title        publisher_id
1    Django入門   1   ← publisher.id=1（講談社）
2    Python実践   2   ← publisher.id=2（集英社）
```

**リレーション**
- **Publisher : Book = 1 : N**  
  - 1つの出版社は複数の本を出版できる。  
  - 1冊の本は必ず1つの出版社に属する。  


### Django モデル操作（CRUDまとめ）

**基本**
- Djangoでは **`モデルクラス.objects`** を通してデータベースにアクセスする。  
- Manager（デフォルトは `objects`）経由で **CRUD操作** ができる。  


**Create（作成）**
```python
Book.objects.create(title="Django入門", price=3000)
```
→ `book` テーブルに新しいレコードを追加。


**Read（読み取り）**
```python
Book.objects.all()              # 全件取得（QuerySet）
Book.objects.get(id=1)          # 主キーで1件取得（存在しないと例外）
Book.objects.filter(price=3000) # 条件検索
```
→ データを取得。`filter()` などは **QuerySet** を返すので、さらにチェーン可能。


**Update（更新）**
```python
book = Book.objects.get(id=1)  # レコード取得
book.price = 3500              # 値を変更
book.save()                    # 保存（UPDATE）
```
→ 取得したオブジェクトを変更して `.save()` で更新。


**Delete（削除）**
```python
book = Book.objects.get(id=1)  # レコード取得
book.delete()                  # 削除
```
→ 指定したレコードを削除。


**まとめ**
- **`モデルクラス.objects`** = データベース操作の窓口。  
- **CRUD**  
  - Create → `.create()`  
  - Read → `.all()`, `.get()`, `.filter()`  
  - Update → オブジェクト更新 + `.save()`  
  - Delete → `.delete()`  

→ 「クラス名.objects.CRUD」でDBに保存されているオブジェクトを操作できる。

---

### Django モデルとデータベースの対応関係

**1. モデルクラス**
```python
class Book(models.Model):
    title = models.CharField(max_length=255)
    price = models.IntegerField()
```
- **モデルクラス（Book）** = データベースの **テーブル**
- この例では `book` テーブルを表す


**2. フィールド**
```python
title = models.CharField(max_length=255)
price = models.IntegerField()
```
- **フィールド** = テーブルの **カラム（列）**
- `title` → 本のタイトル
- `price` → 本の価格

**3. インスタンス（オブジェクト）**
```python 
book = Book.objects.create(title="Django入門", price=3000)
```
- **インスタンス（book）** = テーブルの **1行（レコード）**
- `book.title` → そのレコードの title カラムの値
- `book.price` → そのレコードの price カラムの値


**4. objects（モデルマネージャ）**
```python
Book.objects.all()
Book.objects.filter(price=3000)
```
- **objects** = テーブルのデータを操作するための入り口
- デフォルトでは `objects` が用意されている
- CRUD操作（作成・読み取り・更新・削除）はすべてここから行う

**まとめ**
- **モデルクラス** → テーブル  
- **フィールド** → カラム（列）  
- **インスタンス** → レコード（行）  
- **objects** → データ操作の窓口（クエリを投げる入り口）

---

### Django モデル操作の範囲

**モデルマネージャ（objects）経由 → テーブル全体 / 複数行を対象にする操作**
- `Book.objects.all()` → 全件  
- `Book.objects.filter(price=1000)` → 条件に合う行をまとめて  
- **SQLイメージ**：`SELECT ... FROM book ...`  

**インスタンスメソッド（save(), delete()） → 特定の1行を対象にする操作**
- 1つのオブジェクトに対して値を変えて `.save()`  
- 1つのオブジェクトに対して `.delete()`  
- **SQLイメージ**：`INSERT`, `UPDATE`, `DELETE` （1行）  

**まとめフレーズ**
Djangoの操作は「全体に対する操作（Manager）」と「1行に対する操作（インスタンスメソッド）」の2段構え。  
どの範囲を対象にするかの違いで理解するとスッキリ。

---

### ORM（Object Relational Mapping）まとめ

**ORMとは？**
- **データベースの表形式データ（テーブル・レコード）** を  
  **オブジェクト指向のクラス・インスタンス** に対応させて扱えるようにする仕組み。
- Djangoなどのフレームワークが提供している。

**対応関係**
- **テーブル** ⇔ **モデルクラス**  
- **カラム（列）** ⇔ **フィールド**  
- **レコード（行）** ⇔ **インスタンス（オブジェクト）**  

**特徴**
- SQLを直接書かなくてもPythonコードでDBを操作できる。  
- クエリはDjangoが裏でSQLに変換して発行してくれる。  
- オブジェクト指向の感覚でデータを扱える。  


**具体例**

**Djangoコード（Python）**
```python
book = Book.objects.create(title="Django入門", price=1500)
```

**裏で発行されるSQL**
```sql
INSERT INTO book (title, price) VALUES ('Django入門', 1500);
```

**メリット**
- SQLを意識せずにDB操作ができる  
- コードがシンプルで読みやすい  
- DBを抽象化するので、DBエンジンを変更してもコードの修正が少なくて済む  


**デメリット**
- 複雑なSQLをORMだけで書こうとすると逆にわかりづらくなる  
- 生のSQLに比べてパフォーマンス調整が難しい場合がある  

---

### Django 設定：ATOMIC_REQUESTS = True

**ATOMIC_REQUESTS とは？**
- リクエストごとに自動で **トランザクション** を張る設定。  
- デフォルトは False（手動で transaction.atomic() を使う必要あり）。  


**トランザクションとは？**
- 一連の処理をまとめて「全部成功したら反映・失敗したら全部キャンセル」する仕組み。  
- 例：銀行振込  
  1. Aさんの口座から引き落とす  
  2. Bさんの口座に入金する  
  → どちらか失敗したら **両方キャンセル**（ロールバック）


**動作の流れ**
1. リクエスト開始 → 自動でトランザクション開始  
2. ビュー処理が正常終了 → 自動でコミット（DBに反映）  
3. 例外発生 → 自動でロールバック（DBを元に戻す）  


**メリット**
- **データの整合性が保たれる**  
- 開発者が毎回 `transaction.atomic()` を書かなくてもよい  

** デメリット **
- すべてのリクエストがトランザクション対象になるので  
  更新処理が多いアプリでは **パフォーマンスに影響** が出ることもある  

---

### Djangoで発行されるSQLを確認する方法

**1. Djangoシェルを使う**
```bash
python manage.py shell
```
```python
qs = Book.objects.filter(price=1500)
print(qs.query)
```
→ ORMコードがどんなSQLに変換されるかを確認できる。


**2. ロギングの設定を変更する**
`settings.py` に以下を追加：
```python
LOGGING = {
    'version': 1,
    'disable_existing_loggers': False,
    'handlers': {
        'console': {'class': 'logging.StreamHandler'},
    },
    'loggers': {
        'django.db.backends': {
            'handlers': ['console'],
            'level': 'DEBUG',
        },
    },
}
```
→ 実行中のSQLがコンソールに出力される。


**3. django-debug-toolbar の SQLパネルを使う**
- インストール：
  ```bash
  pip install django-debug-toolbar
  ```
- `INSTALLED_APPS` と `MIDDLEWARE` に追加。  

→ ブラウザ上で実行された全SQL、発行回数、実行時間、EXPLAINを確認できる。


**まとめ **
- **シェル**：特定のORMコードのSQLを確認したいとき  
- **ロギング**：アプリ全体で実行されたSQLをコンソールで確認したいとき  
- **debug-toolbar**：SQLの発行状況や性能をブラウザで直感的に確認したいとき

---

### Django：クエリ最適化 `select_related` / `prefetch_related`

**まず前提：N+1問題**
- 例）本一覧を表示しつつ出版社名も出すとき、各レコードで関連を取りに行くと **1（一覧）+ N（関連）** で大量クエリが発行される。
- 対策が `select_related` と `prefetch_related`。


**使い分けの指針**
- **`select_related`**：**1対1 / 多対1**（外部キー・OneToOne）など **単一オブジェクト** を辿るとき
  - JOIN して **1クエリ** にまとめる
  - 例：`Book -> publisher`（FK）
- **`prefetch_related`**：**1対多 / 多対多 / 逆参照**（related manager で複数行）など **複数オブジェクト** を辿るとき
  - **別クエリ**で一括取得して Python 側で紐付け（2クエリ以上だが N+1 は避けられる）
  - 例：`Publisher -> book_set`、`Book -> authors (M2M)`

---

### Djangoテンプレート：フィルタのメモ

**概要**
- フィルタは **「表示直前の値をサッと加工するためのパイプ」**。
- `{{ ... }}` の中には if/for などのロジックは書けないが、**見た目の整形**はフィルタで行う。

**基本構文**
```django
{{ 変数 | フィルタ名 }}
{{ 変数 | フィルタ名:引数 }}
{{ 変数 | フィルタA | フィルタB:引数 }}  {# チェーン可 #}
```

**よく使うフィルタ例**
```django
{{ user.username|upper }}                     {# 大文字化 #}
{{ user.nickname|default:"名無し" }}          {# 未設定ならデフォルト表示 #}
{{ user.date_joined|date:"Y-m-d" }}          {# 日付整形 #}
{{ price|floatformat:2 }}                     {# 小数点以下2桁 #}
{{ text|truncatechars:20 }}                   {# 20文字で切って…を付ける #}
{{ tags|join:", " }}                          {# リストを区切り文字で連結 #}
{{ body|linebreaksbr }}                       {# 改行→<br> 変換 #}
{{ email|urlize }}                            {# URL/メールをリンク化 #}
{{ items|length }}                            {# 要素数 #}
```

## 次やること
- Django_公式チュートリアル
- Django_教科書

## 感じたこと
- 長時間集中することが難しい。気分変換に英語を勉強しようか計画中。
- 継承とインスタンスを追うのが大変。Djangoの流れは大方理解できたきたけど、詳細が難しい。

## 学習時間
- 8.35h
