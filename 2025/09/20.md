
## 取り組んだ課題一覧  
- REST_記事完成
- REST_課題
- Django_s1~30

## わかったこと
### DjangoにおけるAPIの仕組み

#### APIとは
- APIそのもの: 「リクエストを受け取って、レスポンスを返す」動作全般のこと。
- JSONを返す場合も、HTMLを返す場合も、基本は同じ仕組み。

#### DjangoでAPIを実現する仕組み
1. urls.py
   - リクエストの入口を定義する
   - どのURLにアクセスが来たら、どの処理（view）に渡すかを決める  
   - 例: `/news → view_news`, `/blog → view_blog`

2. views.py
   - 実際の処理を記述する
   - リクエストを受け取ってレスポンスを返す
   - JSONでもHTMLでも可能
   - APIの「中身」にあたる部分

3. models.py
   - データベースとのやり取りを担当
   - 必要に応じて使う（必須ではない）
   - 例: ユーザー情報をDBから取得してレスポンスに含める

#### まとめ
- urls.py … 「この住所に来たら、どの部屋に行くかを決める」
- views.py … 「部屋の人が実際に応答する」
- models.py … 「応答するために倉庫（DB）から資料を持ってくる」

#### 結論
- DjangoにおけるAPIは、urls.py + views.py (+ models.py) を組み合わせて実現される
- DBを使わない固定レスポンスでもAPIになる
- つまり「API = リクエストを受け取ってレスポンスを返す仕組み」

---

### Djangoと仮想環境、startprojectの関係

#### 仮想環境とは
- プロジェクト専用の Python 環境
- Django や依存ライブラリをインストールする場所
- システム全体に影響を与えず、プロジェクトごとに環境を分けられる

#### Djangoとは
- Webアプリケーションを動かすための「仕組み」
- Django 自体は **ソースコードを探して動かすだけ**
- 自分のアプリケーション用のソースコードは別に必要

#### startprojectとは
- Django プロジェクトの **ひな型を自動生成**するコマンド
- 実行例:

```bash
django-admin startproject mysite
```

- 実行すると次のような構造が作られる

```
mysite/
├── manage.py
└── mysite/
    ├── __init__.py
    ├── settings.py
    ├── urls.py
    ├── asgi.py
    └── wsgi.py
```

- `manage.py` : 開発サーバー起動、マイグレーションなどに使う
- `settings.py` : プロジェクト全体の設定
- `urls.py` : URLルーティング
- `wsgi.py/asgi.py` : デプロイ時に使うエントリーポイント

#### なぜ仮想環境の中に作らないのか
1. **管理が混ざる**  
   仮想環境の中はライブラリ専用。ソースと一緒にすると分かりにくい。
2. **再作成できなくなる**  
   仮想環境は壊れたり不要になったら作り直すことがある。そのときソースも消えてしまう。
3. **チーム開発に不向き**  
   仮想環境は配布不要、ソースコードだけ共有すればよい。混ざるとGit管理が面倒。

#### まとめ
- **仮想環境** = ライブラリを入れる箱  
- **startproject** = ソースコード（雛形）を作るコマンド  
- **ベストプラクティス** = 仮想環境とソースコードは別フォルダに分ける
*ベストプラクティス** = 仮想環境とソースコードは別フォルダに分ける

---

### 仮想環境と有効化の意味

#### 仮想環境とは
- プロジェクトごとに独立した Python の環境を作る仕組み
- その中に Django や依存ライブラリをインストールする

#### 有効化の意味
- `source venv_name/bin/activate` を実行すると **PATH が切り替わる**
- 以降の `python`, `pip`, `django-admin` は **仮想環境内のもの** が呼ばれる
- どのフォルダにいても、実行は仮想環境の中で行われる

---

### 実際の挙動
#### 有効化している場合
```bash
source Django_practice/bin/activate

pip install django
# → Django_practice/lib/... にインストールされる

django-admin startproject helloworld
# → 今いるフォルダに helloworld プロジェクトが作られる
```

#### 有効化していない場合
```bash
pip install django
# → システム全体（グローバル環境）にインストールされる
# 他のプロジェクトと競合するリスクあり
```

#### まとめ
- **「仮想環境の中でやる」 = 仮想環境を有効化して操作すること**
- **物理的に仮想環境フォルダに移動する必要はない**
- 有効化していれば、すべての `pip install` や `django-admin` の操作は仮想環境内に反映される
```
~/Desktop/python
├── Django_practice/        ← 仮想環境（ライブラリ置き場）
│   ├── bin/
│   ├── lib/
│   └── pyvenv.cfg
└── helloworldproject/      ← startprojectで生成されたソースコード
    ├── manage.py
    └── helloworldproject/
        ├── settings.py
        ├── urls.py
        └── ...
```

---

### venv と Docker の違い

#### venv（Python仮想環境）
- 実体はただのフォルダ
- `source venv/bin/activate` で **PATH が切り替わる**だけ
- 以降の `python`, `pip`, `django-admin` は仮想環境内のものが呼ばれる
- 普段のコマンド（python, pip）をそのまま使える
- 軽量でセットアップが速いが、Python 専用の環境に限られる

#### Docker
- OS レベルで環境を分離（軽量VMのようなもの）
- `docker run`, `docker exec` など **専用のコマンドが必要**
- Python だけでなく、DB・Webサーバ・他の言語も含めてまとめて管理できる
- 再現性が高く、チーム開発や本番運用で強い
- その分、操作や構築が少し重い


#### まとめ
- **venv** = PATH の切り替えで簡単に Python 専用環境を分ける仕組み  
- **Docker** = コンテナを立ち上げて環境ごと分ける仕組み  
- venv はシンプルで軽量、Docker は汎用性と再現性に優れる

---

### 仮想環境と PATH の切り替え

#### 仮想環境の実態
- Docker のように「独立した空間（コンテナ）」があるわけではない
- 実態はただのフォルダ（例: `Django_practice/`）
  - `bin/` → python, pip, django-admin などの実行ファイル
  - `lib/` → site-packages（pip install したライブラリ）
- 特殊なのは「PATH の切り替え」であって、仕組み自体は単純



#### 有効化の仕組み
- `source venv/bin/activate` をすると **PATH が書き換わる**
- 以降のコマンド検索順序が変わる
  1. `Django_practice/bin/`
  2. それ以外の通常の PATH
- そのため `python`, `pip`, `django-admin` は仮想環境内のものが優先される



#### 実際の結果
- `python` → `Django_practice/bin/python` が呼ばれる  
- `pip` → `Django_practice/bin/pip` が呼ばれる  
- `django-admin` → `Django_practice/bin/django-admin` が呼ばれる  
→ グローバルのものではなく、仮想環境のものを使う状態になる

---

### PATH 切り替えのイメージ例

### 1. 工具箱のラベルを貼り替えるイメージ
- 普段は「家の共用工具箱（= グローバル環境）」からドライバーやレンチを取って使っている  
- `source venv/bin/activate` をすると、机の上に「このプロジェクト専用の工具箱（= 仮想環境）」を置く  
- 以降は「工具を探すとき、まずこの箱から探す」というルールに切り替わる  
- 実際の工具（= コマンド）はただのファイルだけど、**探す優先順位（PATH）が変わる**  


#### まとめ
- 仮想環境 = 専用フォルダ（bin, lib を持つ）
- 有効化すると PATH が切り替わり、仮想環境内のコマンドが優先される
- 物理的に「箱」に入るわけではなく、「探す順番が変わる」仕組み

---

### 仕組みの本質

#### 基本の流れ
1. **設定やコードを読む**  
2. **その指示通りに実行する**  
3. **見つかれば実行成功、無ければエラー**

#### 今回のエラーの例
- Django 3.2 → 「`distutils` を探せ」と指示  
- Python 3.13 → もう `distutils` が削除されていた  
- → 指示はあったが実体が無いので `ModuleNotFoundError` が発生


#### まとめ
- 仕組み = 「指示を読む → 実行する」の繰り返し  
- 存在しないものを指示すれば必ずエラーになる  
- バージョン違いは「指示と実体のずれ」が原因でエラーを生む

---

### Djangoと仮想環境、プロジェクトの関係整理

#### HTTPのWebサイトの基本
- クライアント（ブラウザ）がサーバーへリクエストを送る  
- サーバーは該当の情報を処理してレスポンスを返す  
- → **リクエスト & レスポンス** の繰り返しでWebは成り立っている

#### Django（フレームワーク）
- サーバーサイドの処理を効率的に実装できる仕組み  
- 主な役割  
  - `urls.py` : どのURLにどの処理を割り当てるか  
  - `views.py` : リクエストを受けてレスポンスを返す処理  
  - `models.py` : DBとのやり取り  
- **HTTPの仕組みを簡略化し、再利用可能な形で提供してくれる**

#### 仮想環境 (venv)
- Djangoなどのライブラリをインストールして動かす専用の環境  
- プロジェクトごとに分けられるので、**PythonやDjangoのバージョンを合わせやすい**  
- `source venv/bin/activate` で環境を有効化すると、以降の `python` や `pip` はその仮想環境内のものを参照する

---

### startproject
- Djangoプロジェクトの雛形を生成するコマンド  
- 例:  
  ```bash
  django-admin startproject mysite
  ```
- 作られるファイル例:  
  - `manage.py` : サーバー起動やマイグレーションに使う  
  - `settings.py` : プロジェクト全体の設定  
  - `urls.py` : URLルーティング  
- **自分が開発するソースコードの土台を自動生成する**

#### ソースコードとフレームワークの関係
- Django本体（フレームワーク） = ただのライブラリ  
- プロジェクトのソースコード = 自分で作るアプリケーション  
- → **フレームワークのフォルダ（仮想環境）にソースコードを置くのはNG**  
- 理想: 仮想環境（venv）とプロジェクトのソースは別フォルダに分けて管理する

#### まとめ
- **HTTP** : クライアント→サーバー間のリクエスト&レスポンス  
- **Django** : サーバーサイド処理を効率化するフレームワーク  
- **venv** : Djangoをインストールして動かす専用の環境（バージョン管理に最適）  
- **startproject** : ソースコード雛形を自動生成するコマンド  
- **ソースコードはフレームワークとは別物** → 仮想環境と分けて管理するのが理想

--- 

### Djangoのプロジェクトとアプリの関係

#### プロジェクト
- Django全体の「箱（大元の入れ物）」
- 設定ファイルが入っている
  - `settings.py`
  - `urls.py`
  - `wsgi.py` など

#### アプリ
- プロジェクトの中に複数作れる「機能ごとの部品」
- 例：ブログ機能、Todo機能、ユーザー管理機能
- それぞれに以下が用意できる
  - `views.py`
  - `models.py`
  - `urls.py`
  - `templates/`

#### Viewの位置づけ
- viewは「プロジェクト直下」には置かない
- 各アプリの中にある `views.py` にまとめるのが基本

#### ディレクトリ構成例
```bash
myproject/
 ├── myproject/        ← プロジェクト本体（設定）
 │    ├── settings.py
 │    ├── urls.py
 │    └── ...
 ├── todo/             ← アプリA（Todo機能）
 │    ├── views.py     ← Todo用のView
 │    ├── models.py
 │    └── urls.py
 ├── blog/             ← アプリB（Blog機能）
 │    ├── views.py     ← Blog用のView
 │    ├── models.py
 │    └── urls.py
```

---

## 次やること
- REST_記事装飾
- Django_udemy_s30~40

## 感じたこと
- Python→Python演習→DB→API→Djangoのロードマップの流れ美しすぎて1人で「なるほどおお」って感動してた。頭の中で知識が結ばれていく感覚がした
- 朝の2時間の学習がしっかりできるかできないかで1日が決まる。今日は無理なく集中できた。

## 学習時間
- 8.25h
