## 取り組んだ課題一覧  
- 達人記事
- DB演習
- docker復習

## わかったこと
### DOAとPOAの違い

DB設計のアプローチには大きく分けて2つある

#### DOA（Data Oriented Approach：データ指向アプローチ）
- **考え方**: データを中心に設計する  
- **進め方**:  
  1. どんなデータが必要かを整理（ER図、正規化など）  
  2. そのデータ構造に合わせてアプリや業務フローを作る  
- **メリット**:  
  - データの整合性・一貫性が高い  
  - 長期的な運用や拡張に強い  
- **デメリット**:  
  - 初期設計の手間が大きい  
  - 変化が激しい開発にはやや不向き  

#### POA（Process Oriented Approach：プロセス指向アプローチ）
- **考え方**: 業務フローを中心に設計する  
- **進め方**:  
  1. ユーザーの操作や業務の流れを定義（ユースケース、フローチャート）  
  2. その流れに必要なデータを設計する  
- **メリット**:  
  - ユーザー視点での設計がしやすい  
  - 短期開発や試作でスピード感が出る  
- **デメリット**:  
  - データ構造が後付けになりやすく、非効率なDBになりがち  
  - 長期運用で負債化しやすい  

**システム開発で大切なのは「コーディング ＜ データ設計」**
>建築に例えるとデータ設計が基礎工事でコーディングが建築工事なので、長期化を見据えるならDOAで設計をする。また、プログラム自体は変わることが多いが、データは基本的に変わることはないためデータから設計することが好ましい

--- 

### 論理設計
- **目的**: 業務要件をもとに「データの意味・関係」を明確にする
- **主なステップ**
  1. **エンティティの抽出**  
     → 業務で管理すべき対象を洗い出す（顧客・商品・注文など）
  2. **エンティティの定義**  
     → 属性（カラム候補）やキーを定義する
  3. **正規化**  
     → データの重複や不整合をなくし、整合性を保つ
  4. **ER図の作成**  
     → エンティティ間の関係を図で表現する（1対多、多対多など）

---

### 物理設計
- **目的**: 論理設計を基に、実際のDBMS上で効率的に実装できるように調整する
- **主なステップ**
  1. **テーブル定義**  
     → データ型や制約（NOT NULL、UNIQUE、外部キーなど）を決める
  2. **インデックス定義**  
     → 検索やJOINに使うカラムにインデックスを付ける
  3. **ハードウェアのサイジング**  
     → CPU・メモリ・ディスク容量を見積もる
  4. **ストレージの冗長構成決定**  
     → RAIDやクラウドストレージ構成を選択する
  5. **ファイルの物理配置決定**  
     → テーブルスペースやデータファイルの配置を決める（I/O分散など）


#### まとめ
- 論理設計 = 「どんなデータをどう関連付けるか」を決める（構造の設計）  
- 物理設計 = 「それをどう効率的に実装するか」を決める（運用の設計）  

---

### やってはいけない論理設計（アンチパターン）

#### 1. 非スカラ値
- **内容**: 1つのセルに2つ以上の値を入れる  
- **例**: 「電話番号」列に `090-xxxx,080-xxxx` を保存  
- **問題**: 検索や更新が困難（正規化の原則違反）  
- **改善**: 値ごとに行を分けるか、別テーブルにする  

#### 2. ダブルミーニング
- **内容**: 1つの列に途中から別の意味を持たせる  
- **例**: 「体重」列に年齢を入れるようにした  
- **問題**: 列の意味が一貫せず、過去データと新データを一緒に扱えない  
- **改善**: 意味ごとに列を分ける（体重列と年齢列を別にする）  

#### 3. 単一参照テーブル
- **内容**: すべてのコード値やマスタ値を1つの巨大テーブルにまとめる  
  例: `コードマスタ(コード種別, コード値, コード名)` に「性別」「都道府県」「ステータス」など全部入れる  

- **問題**:
  - 列の意味が1つに統一されず、テーブルの責務があいまいになる  
  - 「コード種別」で毎回絞り込む必要があり、クエリの可読性が悪い  
  - データの整合性チェック（外部キー制約）が使えない  
    - 例: 性別カラムに「都道府県コード」が入ってもDB的には検知できない  

- **改善**:
  - 種別ごとにマスタを分ける  
    - 性別マスタ  
    - 都道府県マスタ  
    - ステータスマスタ  
  - それぞれのテーブルに外部キーを貼れるようにすることで、整合性が保証される  

#### 4. テーブル分割
#### 水平分割の欠点
1. **意味的な理由がない**
   - 「2024年注文」「2025年注文」のように年で分けても、データの意味は同じ  
   - 本来1つのテーブルで持つべきものを無理に分けてしまう  

2. **拡張性に乏しい**
   - 年ごとにテーブルを増やすと、将来さらに「2026年注文」「2027年注文」と際限なく増える  
   - 新しい分割が必要になるたびにアプリやSQLを書き換える必要が出る  

3. **代替手段がある**
   - ほとんどのDBは **パーティション機能** を持っているので、論理的には1テーブルのまま扱える  
   - インデックスやアーカイブ、ビューを活用すればパフォーマンスを確保できる  

#### 垂直分割の欠点
1. **意味的な理由がない**
   - 「ユーザー基本情報」と「ユーザー詳細情報」に分けるような設計をするが、結局は1人のユーザーという同じ意味を持つ  
   - 「1テーブルで表現できるもの」を不自然に分けてしまっている  

2. **拡張性に乏しい**
   - 「よく一緒に使う列」を分けてしまうと、アプリ側で毎回 JOIN が必要になる  
   - 利用シーンが増えるほど結合が複雑化し、将来の拡張に対応しづらい  

3. **代替手段がある**
   - 論理的には1テーブルにまとめておき、必要に応じて **ビュー** や **集約テーブル** で対応すれば十分  
   - アクセス頻度の低いデータは別のストレージに移すなど、物理設計で工夫できる  

#### 5. 不適切なキー
- **内容**: 主キーに可変長文字列を使う（例: メールアドレス、名前）  

- **問題点**:
  1. **値が変わる可能性がある**  
     - メールアドレスや名前はユーザーが変更できる  
     - 主キーが変わると外部キーも連鎖的に修正が必要になり、整合性が崩れる  

  2. **検索効率が悪い**  
     - 可変長文字列はサイズが大きく、インデックス効率が低い  
     - 数値型や固定長よりも検索・JOINが遅くなる  

- **改善**:
  - 主キーは **短く・不変な値（数値ID, UUIDなど）** を使う  
  - 可変長文字列は「ユニーク制約」をかけて **候補キー** として利用する  
    - 例: `users(id(PK), email(Unique), name, ...)`


## 次やること
- DB演習
- docker復習

## 感じたこと
- 朝早く起きれると充実感を持って勉強を始めることができる
- 運動をしているからか勉強時間を伸ばすことができている

## 学習時間
- 8.25h
