## 取り組んだ課題一覧  
- Python_Progate
  - 学習レッスン4.5

## わかったこと
### Python 制御構文まとめ：`return` / `break` / `continue`

- `return`：**関数を終了**し、値を返す  
- `break`：**ループだけを終了**（関数は続く）  
- `continue`：**今回の反復をスキップ**して次へ

---

### `return`
- 役割：関数の終了（ループ内にあっても関数ごと止まる）
- 使いどころ：結果が確定したら、それ以上の処理を打ち切りたい

```python
def demo_return():
    for i in range(5):
        if i == 2:
            return "2で終了"   # 関数ごと終了
        print(i)
    return "最後まで回った"

print(demo_return())
```

**実行結果（概略）**
```
0
1
→ "2で終了"
```

---

### `break`
- 役割：そのループだけを抜ける（関数は続く）
- 使いどころ：探索で「見つかったらもうループ不要」

```python
def demo_break():
    for i in range(5):
        if i == 2:
            break            # ループを抜ける（関数は続く）
        print(i)
    return "ループ後の処理に到達"

print(demo_break())
```

**実行結果（概略）**
```
0
1
→ "ループ後の処理に到達"
```

---

### `continue`
- 役割：現在の反復をスキップして次へ
- 使いどころ：条件に合わない要素を飛ばして処理

```python
def demo_continue():
    for i in range(5):
        if i == 2:
            continue         # i==2 のときだけ出力をスキップ
        print(i)
    return "ループ完了"

print(demo_continue())
```

**実行結果（概略）**
```
0
1
3
4
→ "ループ完了"
```

---

### 在庫更新の例（`return` と `break` の使い分け）

```python
items = [
    {"id": 1, "name": "ゲームソフト", "stock": 15},
    {"id": 2, "name": "ヘッドホン", "stock": 30},
    {"id": 3, "name": "スマートフォン", "stock": 10},
]

# 正解パターン：一致したら在庫更新して return、見つからなければ最後にエラー
def restock_item(item_id, add_stock_count, items):
    for item in items:
        if item_id == item["id"]:
            item["stock"] += add_stock_count
            return "商品の在庫を更新しました"
    return "エラー：在庫を更新できませんでした"

print("[正解] id=3:", restock_item(3, 5, items))   # → 更新OK
print("[正解] id=4:", restock_item(4, 5, items))   # → 見つからずエラー

# break を使う別解：フラグで「見つかったか」を記録して最後に判断
def restock_item_with_break(item_id, add_stock_count, items):
    updated = False
    for item in items:
        if item_id == item["id"]:
            item["stock"] += add_stock_count
            updated = True
            break            # 見つかったのでループだけ終了
    return "商品の在庫を更新しました" if updated else "エラー：在庫を更新できませんでした"

print("[break] id=3:", restock_item_with_break(3, 5, items))
print("[break] id=4:", restock_item_with_break(4, 5, items))

# 悪い例：for 内の else で即 return（最初の要素が不一致だと即エラーで終了）
def bad_restock_item(item_id, add_stock_count, items):
    for item in items:
        if item_id == item["id"]:
            item["stock"] += add_stock_count
            return "商品の在庫を更新しました"
        else:
            return "エラー：在庫を更新できませんでした"

print("[悪い例] id=3:", bad_restock_item(3, 5, items))  # 1件目が不一致→即エラー
```

---

### 使い分けまとめ
1. **処理全体をそこで終わらせたい** → `return`  
2. **ループだけ終わらせて次の処理に移りたい** → `break`  
3. **条件に合わないときだけスキップしたい** → `continue`


# Pythonのインスタンスに後から属性を追加できる仕組み

## 基本
- Pythonのインスタンスは、生成後に自由に属性（変数）を追加できる
- `インスタンス.属性名 = 値` と代入した時点で、その属性が新しく作られる

```python
class Sample:
    pass

s = Sample()
s.name = "Takuma"   # この時点で name 属性が追加される
s.age = 28          # age 属性も追加される

print(s.name)  # → Takuma
print(s.age)   # → 28
```

---

### 特徴
- `__init__` に定義していなくても属性を後から作れる
- インスタンスごとに持つ属性が異なることも可能
- 動的で柔軟だが、コードの見通しが悪くなる場合がある

---

### 注意点
- クラス定義を見ただけでは「そのインスタンスが何を持つか」が分かりにくい
- あるインスタンスには属性があるのに、別のインスタンスには無い、という状態になる可能性がある

```python
s1 = Sample()
s1.x = 10   # s1にはxがある

s2 = Sample()
print(s2.x) # AttributeError（s2にはxがない）
```

---

### まとめ
- Pythonではインスタンスに後から属性を追加できる
- 柔軟だが、設計上「必須の属性」は `__init__` で定義しておく方が安全で可読性も高い



### Pythonの `super()` メモ

### 基本
- `super()` は **親クラスのメソッドを呼び出す仕組み**
- 特に `__init__` で使うと、**親クラスの初期化処理を再利用**できる
- 子クラスで `__init__` を定義すると、親の `__init__` は自動では呼ばれないため、必要なら `super().__init__(...)` を書く

---

### 例1：super() を使わない場合
```python
class Parent:
    def __init__(self, name):
        self.name = name

class Child(Parent):
    def __init__(self, name, age):
        # super()を呼んでいない
        self.age = age

c = Child("Takuma", 28)
print(c.age)    # → 28
print(c.name)   # → AttributeError (親の __init__ が呼ばれていない)
```

---

### 例2：super() を使う場合
```python
class Parent:
    def __init__(self, name):
        self.name = name

class Child(Parent):
    def __init__(self, name, age):
        super().__init__(name)  # 親の初期化を実行
        self.age = age

c = Child("Takuma", 28)
print(c.name)  # → Takuma
print(c.age)   # → 28
```

---

### メリット
- 共通の初期化処理を簡潔に書ける
- 親のコード変更にも柔軟に対応できる
- 子クラスは「追加部分」だけ記述すればよい

---

### まとめ
- `super()` は親クラスのメソッドを呼ぶ仕組み  
- `__init__` が子クラスで再定義されると、親の `__init__` は自動では呼ばれない  
- 必要に応じて `super().__init__(...)` を呼び出すことで、共通部分を引き継ぎつつ拡張できる

## 次やること
- Pyhotn_自販機課題実装

## 感じたこと
- 分からないことでも3.4週と繰り返し勉強すれば徐々に理解できていく。理解した時楽しく感じる。
- 勉強はしっかり出来ているがその他のめんどくさいタスクを後回しにしてしまいがちなのでルーティン化してサクサクと終わらせる。

## 学習時間
- 7.60h
